 <!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FIXORIUM - Solana SPL Token Swap DApp</title>

<!-- React and ReactDOM -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

<!-- axios -->
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

<!-- solana-web3.js -->
<script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.75.0/lib/index.iife.min.js"></script>

<style>
  body {
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    max-width: 480px;
    margin: 30px auto 70px auto;
    font-size: 14px;
    background: #f9f9f9;
    color: #222;
    padding: 0 15px 0 15px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    user-select: none;
    min-height: 100vh;
  }
  h1 {
    font-weight: 900;
    text-align: center;
    margin-bottom: 10px;
    font-size: 2rem;
    color: #007aff;
    user-select: text;
  }
  button {
    cursor: pointer;
    background-color: #007aff;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 8px 16px;
    font-size: 0.9rem;
    transition: background-color 0.3s ease;
    user-select: none;
  }
  button:hover:not([disabled]){
    background-color: #005ecb;
  }
  button[disabled]{
    background-color: #a0a0a0;
    cursor: not-allowed;
  }
  fieldset {
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 15px;
    margin-top: 12px;
    background: white;
  }
  legend {
    font-weight: 700;
    font-size: 1.1rem;
    padding: 0 8px;
  }
  label {
    font-weight: 600;
    font-size: 0.85rem;
    margin-bottom: 4px;
    display: block;
  }
  select, input[type=number] {
    width: 100%;
    padding: 6px 8px;
    font-size: 0.9rem;
    border: 1px solid #bbb;
    border-radius: 5px;
    box-sizing: border-box;
    margin-top: 4px;
    margin-bottom: 6px;
    transition: border-color 0.2s ease;
  }
  select:focus, input[type=number]:focus {
    outline: none;
    border-color: #007aff;
    box-shadow: 0 0 3px #007aff66;
  }
  small {
    color: #555;
    display: block;
    margin-top: -4px;
    margin-bottom: 12px;
    font-size: 0.75rem;
    user-select: text;
    word-break: break-word;
  }
  .btn-swap {
    margin: 10px auto;
    display: block;
    font-weight: 600;
    font-size: 1rem;
    user-select: none;
  }
  .route-box {
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 10px;
    margin-bottom: 6px;
    cursor: pointer;
    font-size: 0.875rem;
    background: white;
    transition: border-color 0.25s ease, background-color 0.25s ease;
    user-select: none;
  }
  .route-box:hover {
    border-color: #007aff;
    background-color: #f0f8ff;
  }
  .route-box.selected {
    border-color: #007aff;
    background-color: #e2f0ff;
  }
  p.status {
    margin-top: 20px;
    word-wrap: break-word;
    font-size: 0.85rem;
    color: #005ecb;
    font-weight: 600;
    user-select: text;
    white-space: pre-wrap;
  }
  p.error {
    margin-top: 12px;
    word-wrap: break-word;
    font-size: 0.85rem;
    color: #cc0000;
    font-weight: 600;
    user-select: text;
    white-space: pre-wrap;
  }
  footer {
    margin-top: 40px;
    font-size: 0.75rem;
    color: #666;
    text-align: center;
    user-select:none;
  }
  a {
    color: #007aff;
    text-decoration: underline;
    user-select: text;
  }
</style>
</head>
<body>
  <h1>FIXORIUM</h1>
  <div id="root"></div>

<script type="text/javascript">
  const e = React.createElement;
  const { useState, useEffect, useCallback } = React;
  const { Connection, clusterApiUrl, PublicKey, Transaction } = solanaWeb3;

  const SOL_MINT = "So11111111111111111111111111111111111111112";
  const JUPITER_API_BASE = "https://quote-api.jup.ag/v4";
  const connection = new Connection(clusterApiUrl("mainnet-beta"), "confirmed");

  const tokensList = [
    { address: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", symbol: "USDC", decimals: 6 },
    { address: "Es9vMFrzaCER7N1TvjVqauDziYbPEmxW5M9VpX1TTd8C", symbol: "USDT", decimals: 6 },
    { address: "SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt", symbol: "SRM", decimals: 6 },
    { address: "4k3Dyjzvzp8e4wJ7TGLkpvJ7YenqR6AMx7jxUnnGghPf", symbol: "RAY", decimals: 6 },
    { address: "orcaE6ZxFtoajT2zF3ahNHPs2bWkm8c5KxjxHPv3RRZ4", symbol: "ORCA", decimals: 6 },
    { address: "FTTGFt2jEQq3RpAm3qNihC84sFD3AYwhzMTeKuFzQZ9", symbol: "FTT", decimals: 6 },
    { address: "DezXAZ8z7PnrnRJjzQeCQBmfPtujfq6nCzFFWiP2LsXX", symbol: "BONK", decimals: 0 },
    { address: "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU", symbol: "SAMO", decimals: 9 },
    { address: "CopeJxzv7ss9ruvT8WDD7i5ZRtcQBNM6AtURNyagova", symbol: "COPE", decimals: 9 },
    { address: "StepRfZh3P5GbAmMKB3vTf1GhT7jDLpD5ZYhKv9HQ9H", symbol: "STEP", decimals: 6 },
  ];

  function App() {
    const [walletConnected, setWalletConnected] = useState(false);
    const [publicKey, setPublicKey] = useState(null);
    const [solBalance, setSolBalance] = useState(null);
    const [tokenBalances, setTokenBalances] = useState({});
    const [fromToken, setFromToken] = useState({ address: SOL_MINT, symbol: "SOL", decimals: 9 });
    const [toToken, setToToken] = useState(tokensList[0]);
    const [amount, setAmount] = useState("");
    const [routes, setRoutes] = useState([]);
    const [selectedRoute, setSelectedRoute] = useState(null);
    const [loadingQuotes, setLoadingQuotes] = useState(false);
    const [swapping, setSwapping] = useState(false);
    const [txStatus, setTxStatus] = useState(null);
    const [errorMessage, setErrorMessage] = useState(null);

    const getProvider = () => {
      if (window.solana && window.solana.isPhantom) return window.solana;
      if (window.phantom && window.phantom.solana && window.phantom.solana.isPhantom) return window.phantom.solana;
      return null;
    };

    const toBaseUnits = (amountStr, decimals) => {
      try {
        const v = parseFloat(amountStr);
        if (isNaN(v) || v <= 0) return 0;
        return Math.round(v * 10 ** decimals);
      } catch {
        return 0;
      }
    };

    const connectWallet = useCallback(async () => {
      setErrorMessage(null);
      const provider = getProvider();
      if (!provider) {
        setErrorMessage("Phantom wallet not found. Install Phantom or open in Phantom mobile browser.");
        return;
      }
      try {
        const resp = await provider.connect();
        setPublicKey(new PublicKey(resp.publicKey.toString()));
        setWalletConnected(true);
        setTxStatus(null);
      } catch (e) {
        setErrorMessage("Wallet connection failed or rejected: " + (e.message || e.toString()));
      }
    }, []);

    const disconnectWallet = useCallback(async () => {
      setErrorMessage(null);
      const provider = getProvider();
      if (!provider) {
        setErrorMessage("Phantom wallet not available.");
        return;
      }
      try {
        await provider.disconnect();
      } catch (e) {
        console.warn("Error disconnecting wallet", e);
      }
      setWalletConnected(false);
      setPublicKey(null);
      setSolBalance(null);
      setTokenBalances({});
      setRoutes([]);
      setSelectedRoute(null);
      setTxStatus(null);
      setAmount("");
    }, []);

    useEffect(() => {
      const provider = getProvider();
      if (!provider) return;
      const onConnect = (pk) => {
        setPublicKey(new PublicKey(pk.toString()));
        setWalletConnected(true);
        setTxStatus(null);
        setErrorMessage(null);
      };
      const onDisconnect = () => {
        setWalletConnected(false);
        setPublicKey(null);
        setSolBalance(null);
        setTokenBalances({});
        setRoutes([]);
        setSelectedRoute(null);
        setTxStatus(null);
        setAmount('');
        setErrorMessage(null);
      };
      provider.on("connect", onConnect);
      provider.on("disconnect", onDisconnect);
      if (provider.isConnected) onConnect(provider.publicKey);
      return () => {
        if (provider.removeListener) {
          provider.removeListener("connect", onConnect);
          provider.removeListener("disconnect", onDisconnect);
        }
      };
    }, []);

    useEffect(() => {
      if (!publicKey) return;
      (async () => {
        setErrorMessage(null);
        setSolBalance(null);
        setTokenBalances({});
        try {
          const l = await connection.getBalance(publicKey);
          setSolBalance(l / 1e9);
          let balances = {};
          for (const token of tokensList) {
            try {
              const mintPubkey = new PublicKey(token.address);
              const accounts = await connection.getTokenAccountsByOwner(publicKey, { mint: mintPubkey });
              let total = 0;
              for (const acc of accounts.value) {
                const info = await connection.getParsedAccountInfo(acc.pubkey);
                if (info.value && info.value.data && info.value.data.parsed && info.value.data.parsed.info && info.value.data.parsed.info.tokenAmount) {
                  total += info.value.data.parsed.info.tokenAmount.uiAmount || 0;
                }
              }
              balances[token.address] = total;
            } catch {
              balances[token.address] = 0;
            }
          }
          setTokenBalances(balances);
        } catch (e) {
          console.error("Balance fetching error:", e);
          setErrorMessage("Error fetching wallet balance. Check connection.");
        }
      })();
    }, [publicKey]);

    const getSwapQuotes = async () => {
      setErrorMessage(null);
      if (!publicKey) {
        setErrorMessage("Please connect your wallet first.");
        return;
      }
      const amt = parseFloat(amount);
      if (isNaN(amt) || amt <= 0) {
        setErrorMessage("Enter a valid amount.");
        return;
      }
      setLoadingQuotes(true);
      setRoutes([]);
      setSelectedRoute(null);
      setTxStatus(null);
      try {
        const inputMint = fromToken.symbol === "SOL" ? SOL_MINT : fromToken.address;
        const outputMint = toToken.symbol === "SOL" ? SOL_MINT : toToken.address;
        const amountInBaseUnits = toBaseUnits(amount, fromToken.decimals);
        if (amountInBaseUnits === 0) {
          setErrorMessage("Amount too small after decimal conversion.");
          setLoadingQuotes(false);
          return;
        }
        const resp = await axios.get(JUPITER_API_BASE + "/quote", {
          params: {
            inputMint,
            outputMint,
            amount: amountInBaseUnits,
            slippageBps: 50,
            swapMode: "ExactIn",
          },
        });
        if (resp.data && Array.isArray(resp.data.data) && resp.data.data.length > 0) {
          setRoutes(resp.data.data);
          setSelectedRoute(resp.data.data[0]);
        } else {
          setErrorMessage("No swap routes found for selected tokens and amount.");
          setRoutes([]);
          setSelectedRoute(null);
        }
      } catch (e) {
        console.error("Quote fetching error:", e);
        setErrorMessage("Error fetching swap quotes. Check network.");
      }
      setLoadingQuotes(false);
    };

    const executeSwap = async () => {
      setErrorMessage(null);
      if (!publicKey) {
        setErrorMessage("Please connect your wallet first.");
        return;
      }
      if (!selectedRoute) {
        setErrorMessage("No swap route selected.");
        return;
      }
      setSwapping(true);
      setTxStatus(null);
      try {
        const provider = getProvider();
        if (!provider) {
          setErrorMessage("Wallet not available for signing transactions.");
          setSwapping(false);
          return;
        }
        const resp = await axios.post(JUPITER_API_BASE + "/swap", {
          route: selectedRoute,
          userPublicKey: publicKey.toBase58(),
        });
        if (!resp.data || !resp.data.swapTransactions) {
          setErrorMessage("Failed to get swap transactions from Jupiter.");
          setSwapping(false);
          return;
        }
        const { setupTransaction, swapTransaction } = resp.data.swapTransactions;
        if (setupTransaction) {
          const tx = Transaction.from(Buffer.from(setupTransaction, "base64"));
          tx.feePayer = publicKey;
          const blockhash = (await connection.getLatestBlockhash()).blockhash;
          tx.recentBlockhash = blockhash;
          const signedTx = await provider.signTransaction(tx);
          const txid = await connection.sendRawTransaction(signedTx.serialize());
          setTxStatus("Setup tx sent: " + txid);
          await connection.confirmTransaction(txid, "confirmed");
        }
        const swapTx = Transaction.from(Buffer.from(swapTransaction, "base64"));
        swapTx.feePayer = publicKey;
        const blockhash2 = (await connection.getLatestBlockhash()).blockhash;
        swapTx.recentBlockhash = blockhash2;
        const signedSwapTx = await provider.signTransaction(swapTx);
        const swapTxid = await connection.sendRawTransaction(signedSwapTx.serialize());
        setTxStatus("Swap tx submitted: " + swapTxid);
        await connection.confirmTransaction(swapTxid, "confirmed");
        setTxStatus("Swap tx confirmed: " + swapTxid);

        // Refresh balances
        const l = await connection.getBalance(publicKey);
        setSolBalance(l / 1e9);
        const balances = {};
        for (const token of tokensList) {
          try {
            const mint = new PublicKey(token.address);
            const tokenAccounts = await connection.getTokenAccountsByOwner(publicKey, { mint });
            let sum = 0;
            for (const acc of tokenAccounts.value) {
              const info = await connection.getParsedAccountInfo(acc.pubkey);
              if (info.value && info.value.data && info.value.data.parsed && info.value.data.parsed.info && info.value.data.parsed.info.tokenAmount) {
                sum += info.value.data.parsed.info.tokenAmount.uiAmount || 0;
              }
            }
            balances[token.address] = sum;
          } catch {
            balances[token.address] = 0;
          }
        }
        setTokenBalances(balances);

        setAmount("");
        setRoutes([]);
        setSelectedRoute(null);
        setErrorMessage(null);
      } catch (e) {
        console.error("Swap failed:", e);
        setErrorMessage("Swap failed: " + (e.message || e.toString()));
      }
      setSwapping(false);
    };

    const swapFromTo = () => {
      const oldFrom = fromToken;
      setFromToken(toToken);
      setToToken(oldFrom);
      setAmount("");
      setRoutes([]);
      setSelectedRoute(null);
      setTxStatus(null);
      setErrorMessage(null);
    };

    const displayBalance = (token) => {
      if (token.symbol === "SOL") {
        return solBalance === null ? "Loading..." : solBalance.toFixed(4);
      }
      const bal = tokenBalances[token.address];
      return bal === undefined ? "Loading..." : bal.toFixed(4);
    };

    return e("div", { style: { maxWidth: 480, margin: "30px auto", padding: 15 } },
      e("h1", { style: { color: "#007aff", fontWeight: 900, fontSize: 32, textAlign: "center", userSelect: "text" } }, "FIXORIUM"),

      !walletConnected ?
        e("button", {
          onClick: connectWallet,
          style: { width: "100%", padding: 12, fontSize: 18 },
          type: "button",
          "aria-label": "Connect Phantom Wallet"
        }, "Connect Phantom Wallet")
        :
        e("div", { style: { marginBottom: 15 } },
          e("p", { style: { wordBreak: "break-word", userSelect: "text" } }, e("b", null, "Wallet: "), publicKey ? publicKey.toBase58() : ""),
          e("p", null, e("b", null, "SOL balance: "), solBalance === null ? "Loading..." : solBalance.toFixed(4) + " SOL"),
          e("button", {
            onClick: disconnectWallet,
            style: { padding: "6px 12px", fontSize: 14 },
            type: "button"
          }, "Disconnect")
        ),

      errorMessage && e("p", {
        style: { color: "red", marginTop: 12, fontWeight: "600", whiteSpace: "pre-wrap" },
        role: "alert"
      }, errorMessage),

      e("fieldset", { disabled: !walletConnected || loadingQuotes || swapping, style: { borderRadius: 8, padding: 15, background: "white" } },
        e("legend", { style: { fontWeight: 700, fontSize: 18 } }, "Swap"),
        e("label", { htmlFor: "fromSelect", style: { fontWeight: 600, marginBottom: 4, display: "block" } }, "From:"),
        e("select", {
          id: "fromSelect",
          value: fromToken.address,
          onChange: e => {
            const val = e.target.value;
            const sel = tokensList.find(t => t.address === val) || (val === SOL_MINT ? { address: SOL_MINT, symbol: "SOL", decimals: 9 } : null);
            if (sel) {
              setFromToken(sel);
              setRoutes([]);
              setSelectedRoute(null);
              setAmount("");
              setTxStatus(null);
              setErrorMessage(null);
            }
          },
          style: { width: "100%", padding: 6, fontSize: 14, marginTop: 4, marginBottom: 6 }
        },
          e("option", { value: SOL_MINT }, "SOL"),
          tokensList.map(token => e("option", { key: token.address, value: token.address }, token.symbol))
        ),
        e("small", null, "Balance: ", displayBalance(fromToken)),
        e("button", {
          type: "button",
          onClick: swapFromTo,
          disabled: !walletConnected || swapping || loadingQuotes,
          style: { margin: "10px auto", display: "block", fontWeight: 600, fontSize: 16, userSelect: "none" }
        }, "⇅ Swap from/to"),
        e("label", { htmlFor: "toSelect", style: { fontWeight: 600, marginBottom: 4, display: "block" } }, "To:"),
        e("select", {
          id: "toSelect",
          value: toToken.address,
          onChange: e => {
            const val = e.target.value;
            const sel = tokensList.find(t => t.address === val) || (val === SOL_MINT ? { address: SOL_MINT, symbol: "SOL", decimals: 9 } : null);
            if (sel) {
              setToToken(sel);
              setRoutes([]);
              setSelectedRoute(null);
              setAmount("");
              setTxStatus(null);
              setErrorMessage(null);
            }
          },
          style: { width: "100%", padding: 6, fontSize: 14, marginTop: 4, marginBottom: 6 }
        },
          e("option", { value: SOL_MINT }, "SOL"),
          tokensList.map(token => e("option", { key: token.address, value: token.address }, token.symbol))
        ),
        e("small", null, "Balance: ", displayBalance(toToken)),
        e("label", { htmlFor: "amountInput", style: { fontWeight: 600, marginBottom: 4, display: "block" } }, "Amount (" + fromToken.symbol + "):"),
        e("input", {
          id: "amountInput",
          type: "number",
          min: "0",
          step: "any",
          placeholder: "0",
          value: amount,
          onChange: e => setAmount(e.target.value),
          spellCheck: false,
          inputMode: "decimal",
          style: { width: "100%", padding: 6, fontSize: 14, marginTop: 4, marginBottom: 6 }
        }),
        e("button", {
          onClick: getSwapQuotes,
          disabled: loadingQuotes || !amount || parseFloat(amount) <= 0,
          style: { width: "100%", fontSize: 16, padding: 10 },
          type: "button"
        }, loadingQuotes ? "Loading quotes..." : "Get Swap Quote")
      ),

      routes.length > 0 && !loadingQuotes && e("fieldset", { style: { marginTop: 15, borderRadius: 8, padding: 15, background: "white" } },
        e("legend", { style: { fontWeight: 700, fontSize: 18 } }, "Quotes"),
        e("div", { style: { maxHeight: 250, overflowY: "auto" } },
          routes.map(route => {
            const expectedOut = (parseInt(route.outAmount) / 10 ** toToken.decimals).toFixed(6);
            const priceImpactPct = (route.priceImpactPct * 100).toFixed(3);
            const selected = selectedRoute && selectedRoute.id === route.id;
            return e("div", {
              key: route.id,
              className: "route-box" + (selected ? " selected" : ""),
              onClick: () => setSelectedRoute(route),
              onKeyDown: ev => { if (ev.key === "Enter" || ev.key == " ") setSelectedRoute(route); },
              role: "button",
              tabIndex: 0,
              "aria-pressed": selected,
              "aria-label": `Quote expected out ${expectedOut} ${toToken.symbol}. Price Impact ${priceImpactPct}%. Click to select.`,
              style: {
                border: selected ? "2px solid #007aff" : "1px solid #ccc",
                backgroundColor: selected ? "#e2f0ff" : "white",
                padding: 10,
                marginBottom: 6,
                cursor: "pointer",
              }
            },
              e("div", null, e("b", null, "Expected Out: "), expectedOut, " ", toToken.symbol),
              e("div", null, e("b", null, "Price Impact: "), priceImpactPct, "%"));
          })
        ),
        e("button", {
          onClick: executeSwap,
          disabled: !selectedRoute || swapping,
          style: { marginTop: 15, width: "100%", padding: 10, fontSize: 16 },
          type: "button"
        }, swapping ? "Swapping..." : `Swap ${amount} ${fromToken.symbol} → ${toToken.symbol}`)
      ),

      txStatus && e("p", {
        style: { marginTop: 20, fontWeight: 600, color: "#005ecb", whiteSpace: "pre-wrap" },
        "aria-live": "polite",
        "aria-atomic": "true"
      }, txStatus),

      e("footer", { style: { marginTop: 40, fontSize: 12, color: "#666", textAlign: "center" } },
        "Powered by Solana, Phantom \u0026 ",
        e("a", { href: "https://jup.ag/", target: "_blank", rel: "noopener noreferrer", style: { color: "#007aff", textDecoration: "underline" } }, "Jupiter Aggregator")
      )
    );
  }

  const domContainer = document.querySelector("#root");
  ReactDOM.createRoot(domContainer).render(e(App));
</script>
</body>
</html>

 <!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>FIXORIUM WALLET</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.2/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Reset & base styles */
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #111;
      color: #fff;
      font-family: Arial, sans-serif;
      font-size: 13px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      user-select: none;
      overflow: hidden;
    }

    /* Full screen layout */
    #app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* Header styles */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #181818;
      padding: 8px 12px;
      box-shadow: 0 2px 8px #00ffa833;
      flex-shrink: 0;
    }

    #logo-left {
      font-size: 1.2rem;
      font-weight: 700;
      color: #00ffa8;
      letter-spacing: 0.02em;
      user-select: text;
    }

    #wallet-row {
      display: flex;
      gap: 7px;
      align-items: center;
      min-width: 200px;
      justify-content: end;
      flex-wrap: nowrap;
    }

    #connectWalletBtn,
    #disconnectWalletBtn {
      background: #00ffa8;
      border: none;
      color: #111;
      font-weight: 700;
      padding: 5px 18px;
      border-radius: 6px;
      cursor: pointer;
      min-width: 90px;
      font-size: 13px;
      white-space: nowrap;
      user-select: none;
      text-transform: uppercase;
      box-shadow: 0 1px 8px #00ffa844;
      transition: background 0.2s ease;
      flex-shrink: 0;
    }

    #connectWalletBtn:hover,
    #disconnectWalletBtn:hover {
      background: #00cc7a;
      color: #121212;
    }

    #disconnectWalletBtn {
      background: transparent;
      border: 1.5px solid #00ffa8;      color: #00ffa8;
    }

    #walletAddress {
      font-size: 13px;
      color: #00ffa8;
      letter-spacing: 0.03em;
      font-weight: 600;
      user-select: text;
      white-space: nowrap;
      max-width: 130px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Main content area */
    main {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
      overflow: hidden;
    }

    #totalBalance {
      font-size: 1.15rem;
      margin-bottom: 14px;
      font-weight: 700;
      color: #00ff99;
      text-align: center;
      min-height: 1.8em;
      letter-spacing: 0.05em;
      user-select: text;
      flex-shrink: 0;
      padding-top: 10px;
    }

    .tokens-container {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      overflow: hidden;
      /* Allow internal scrolling if cards are too tall */
    }

    .token-card {
      background: #181c22;
      border-radius: 10px;
      box-shadow: 0 1px 8px #00ffa833 inset;
      display: flex;
      flex-direction: column;
      padding: 12px;
      position: relative;
      transition: box-shadow 0.10s ease, transform 0.15s ease;
      overflow: hidden;
      /* Ensure content within card doesn't overflow */
    }

    .token-card:hover {
      box-shadow: 0 1px 14px #00ffa8cc inset;
      transform: scale(1.01);
    }

    .token-card.compact {
      min-height: 100px;
      /* Adjust compact card height */
      max-height: 120px;
      /* Max height for compact card */
      justify-content: center;
    }

    .token-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .token-symbol {
      font-weight: 700;
      font-size: 16px;
      color: #00ffaa;
      letter-spacing: 0.07em;
    }

    .token-price-info {
      display: flex;
      align-items: baseline;
      gap: 5px;
    }

    .token-price {
      font-size: 14px;
      color: #fff;
      font-weight: 600;
    }

    .token-balance {
      font-size: 24px;
      font-weight: bold;
      margin: 10px 0;
      color: #00ff99;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .price-change {
      font-size: 12px;
      padding: 3px 6px;
      border-radius: 4px;
      font-weight: bold;
    }

    .price-up {
      background-color: rgba(22, 199, 132, 0.2);
      color: #16c784;
    }

    .price-down {
      background-color: rgba(234, 57, 67, 0.2);
      color: #ea3943;
    }

    .chart-container {
      flex: 1;
      min-height: 80px;
      margin-top: 10px;
      overflow: hidden;
      position: relative;
    }

    .price-chart {
      width: 100% !important;
      height: 100% !important;
      max-height: unset !important;
    }

    /* Buy/Sell buttons on token cards */
    .token-actions {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      justify-content: center;
      flex-shrink: 0;
    }

    .token-action-btn {
      background: #00ffa8;
      border: none;
      color: #111;
      font-weight: 700;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      text-transform: uppercase;
      flex: 1;
      transition: background 0.2s ease;
    }

    .token-action-btn:hover {
      background: #00cc7a;
    }

    .token-action-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }


    /* Action buttons at bottom */
    .action-buttons {
      display: flex;
      justify-content: space-around;
      padding: 10px;
      background: #181818;
      border-top: 1px solid #00ffa833;
      flex-shrink: 0;
    }

    .action-btn {
      background: #00ffa8;
      border: none;
      color: #111;
      font-weight: 700;
      padding: 12px 0;
      border-radius: 8px;
      font-size: 15px;
      cursor: pointer;
      transition: background 0.25s ease;
      width: 30%;
      text-align: center;
      text-transform: uppercase;
      box-shadow: 0 3px 10px #00ffa833;
    }

    .action-btn:hover {
      background: #00cc7a;
    }

    .action-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* Signal indicators */
    .signal-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: bold;
      text-transform: uppercase;
      animation: blinky 0.75s steps(1) infinite;
      z-index: 10;
    }

    .buy-signal {
      background-color: rgba(22, 199, 132, 0.2);
      color: #16c784;
      border: 1px solid #16c784;
    }

    .sell-signal {      background-color: rgba(234, 57, 67, 0.2);
      color: #ea3943;
      border: 1px solid #ea3943;
    }

    @keyframes blinky {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.35;
      }

      100% {
        opacity: 1;
      }
    }

    /* Loading state */
    .loading {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid rgba(255, 255, 255, .3);
      border-radius: 50%;
      border-top-color: #00ffa8;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);      }
    }

    /* Modal styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-content {
      background: #181c22;
      padding: 25px;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0, 255, 168, 0.3);
      width: 90%;
      max-width: 400px;
      color: #fff;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-header h2 {
      margin: 0;
      color: #00ffa8;
      font-size: 1.5rem;
    }

    .modal-close-btn {
      background: none;
      border: none;
      color: #00ffa8;
      font-size: 1.8rem;
      cursor: pointer;
    }

    .modal-form label {
      display: block;
      margin-bottom: 8px;
      color: #ddd;
    }

    .modal-form input,
    .modal-form select {
      width: calc(100% - 20px);
      padding: 10px;
      margin-bottom: 15px;
      border-radius: 5px;
      border: 1px solid #00ffa8;
      background: #0e1217;
      color: #fff;
    }    .modal-form button {
      background: #00ffa8;
      border: none;
      color: #111;
      padding: 12px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: bold;
      width: 100%;
      transition: background 0.2s ease;
    }

    .modal-form button:hover:not(:disabled) {
      background: #00cc7a;
    }

    .modal-form button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .modal-status, .modal-error {
      margin-top: 15px;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
      font-weight: bold;
    }

    .modal-status {
      background-color: rgba(0, 255, 168, 0.2);
      color: #00ffa8;
    }

    .modal-error {
      background-color: rgba(234, 57, 67, 0.2);
      color: #ea3943;
    }

    .modal-loader {
      text-align: center;
      margin-top: 15px;
    }
  </style>
</head>

<body>
  <div id="app-container">
    <header>
      <div id="logo-left">FIXORIUM WALLET</div>
      <div id="wallet-row">
        <button id="connectWalletBtn">CONNECT</button>
        <button id="disconnectWalletBtn" style="display:none;">DISCONNECT</button>
        <span id="walletAddress"></span>
      </div>
    </header>    <main>
      <div id="totalBalance" aria-live="polite" aria-atomic="true">Total Balance: $0.00</div>
      <div class="tokens-container" id="tokensContainer">        <!-- Tokens will be rendered here -->
      </div>
    </main>

    <div class="action-buttons">
      <button id="depositBtn" class="action-btn" disabled>Deposit</button>      <button id="withdrawBtn" class="action-btn" disabled>Withdraw</button>
      <button id="exchangeBtn" class="action-btn">Exchange</button>
    </div>
  </div>

  <script>
    (() => {
      const solanaWeb3 = window.solanaWeb3;
      const ChartJS = window.Chart;

      // Token configuration and state
      const tokens = [
        {
          symbol: "SOL",
          name: "Solana",
          mint: "So11111111111111111111111111111111111111112", // SOL mint for Jupiter
          decimals: 9,
          cg: "solana",
          isCompact: false, // For SOL, full size with chart
          hasChart: true,
        },
        {
          symbol: "FIXR",
          name: "Fixercoin",
          mint: "D2mGkp5D43jirFeapx8UZmpiH7FaWeX1eUWy94q1F2hD", // FIXERCOIN mint address
          decimals: 9,
          cg: "", // No CoinGecko for FIXERCOIN
          isCompact: true, // For FIXR, compact size without chart
          hasChart: false,
        }
      ];

      // Global app state
      const state = {
        walletConnected: false,
        publicKey: null,
        provider: window.solana?.isPhantom ? window.solana : null,
        connection: new solanaWeb3.Connection(solanaWeb3.clusterApiUrl("mainnet-beta"), "confirmed"),
        priceUpdateInterval: null,
        balanceUpdateInterval: null,
        modal: {
          isOpen: false,
          type: null, // 'deposit', 'withdraw', 'exchange'
          data: null // Data specific to the modal (e.g., token for exchange)
        },
        modalStatus: null, // Success/error message for modals
        modalError: null,
        modalLoading: false,
      };      // DOM elements cache
      const elements = {
        connectBtn: document.getElementById("connectWalletBtn"),
        disconnectBtn: document.getElementById("disconnectWalletBtn"),
        walletAddress: document.getElementById("walletAddress"),
        tokensContainer: document.getElementById("tokensContainer"),
        totalBalance: document.getElementById("totalBalance"),
        depositBtn: document.getElementById("depositBtn"),
        withdrawBtn: document.getElementById("withdrawBtn"),
        exchangeBtn: document.getElementById("exchangeBtn"),
      };

      // --- Utility Functions ---
      function formatNumber(num, decimals = 4) {
        if (typeof num !== "number" || isNaN(num)) return "-";
        return num.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: decimals });
      }

      async function findATA(walletAddress, tokenMintAddress) {
        return (await solanaWeb3.PublicKey.findProgramAddress(
          [
            walletAddress.toBuffer(),
            solanaWeb3.TOKEN_PROGRAM_ID.toBuffer(),
            tokenMintAddress.toBuffer(),
          ],
          solanaWeb3.ASSOCIATED_TOKEN_PROGRAM_ID
        ))[0];
      }

      function toBaseUnits(amount, decimals) {
        return Math.floor(parseFloat(amount) * (10 ** decimals));
      }

      function fromBaseUnits(amount, decimals) {
        return parseFloat(amount) / (10 ** decimals);
      }

      // --- Wallet Connection Logic ---
      function updateUI() {
        if (state.walletConnected && state.publicKey) {
          elements.connectBtn.style.display = "none";
          elements.disconnectBtn.style.display = "";
          elements.depositBtn.disabled = false;
          elements.withdrawBtn.disabled = false;

          let addrStr = state.publicKey.toBase58();
          addrStr = addrStr.length > 10 ? addrStr.slice(0, 6) + "..." + addrStr.slice(-4) : addrStr;
          elements.walletAddress.textContent = addrStr;
        } else {
          elements.connectBtn.style.display = "";
          elements.disconnectBtn.style.display = "none";
          elements.depositBtn.disabled = true;
          elements.withdrawBtn.disabled = true;
          elements.walletAddress.textContent = "";
        }        updateTokenDisplays(); // Ensure token balances reflect connection state
      }

      async function connectWallet() {
        if (!state.provider) {
          alert("Phantom Wallet not found. Please install it to connect.");          window.open("https://phantom.app/", "_blank"); // Open Phantom download page
          return;
        }

        try {
          const response = await state.provider.connect({ onlyIfTrusted: false });
          state.publicKey = response.publicKey;
          state.walletConnected = true;
          updateUI();
          fetchBalances(); // Fetch balances immediately after connection
        } catch (error) {
          console.error("Wallet connection rejected or failed:", error);
          alert("Wallet connection was rejected or an error occurred.");
        }
      }

      async function disconnectWallet() {
        if (state.provider && state.walletConnected) {          try {
            await state.provider.disconnect();
          } catch (error) {
            console.error("Error during Phantom disconnect:", error);
          }
        }

        state.walletConnected = false;
        state.publicKey = null;
        tokens.forEach(token => {
          token.balance = 0;
        });
        updateUI();
        updateTotalBalance();
      }

      // --- Balance Fetching ---
      async function fetchBalances() {
        // If not connected, balances are zero. Don't throw errors.
        if (!state.walletConnected || !state.publicKey) {
          tokens.forEach(token => token.balance = 0);
          updateTokenDisplays();
          updateTotalBalance();
          return;
        }

        try {
          // Fetch SOL balance
          const solBalanceRaw = await state.connection.getBalance(state.publicKey);
          tokens[0].balance = solBalanceRaw / (10 ** tokens[0].decimals);

          // Fetch FIXR balance
          const fixrToken = tokens[1];
          if (fixrToken.mint) {
            try {
              const fixrMintPubKey = new solanaWeb3.PublicKey(fixrToken.mint);
              const ata = await findATA(state.publicKey, fixrMintPubKey);
              const accountInfo = await state.connection.getParsedAccountInfo(ata);
              if (accountInfo.value?.data?.parsed?.info?.tokenAmount) {
                fixrToken.balance = accountInfo.value.data.parsed.info.tokenAmount.uiAmount;
              } else {
                fixrToken.balance = 0;
              }
            } catch (ataError) {
              console.warn(`Could not get ATA for ${fixrToken.symbol}:`, ataError);
              fixrToken.balance = 0;
            }
          }
          updateTokenDisplays();
          updateTotalBalance();
        } catch (error) {
          console.error("Failed to fetch balances:", error);
          tokens.forEach(token => token.balance = 0);
          updateTokenDisplays();
          updateTotalBalance();
        }
      }

      // --- Price Fetching and Chart Updates ---
      async function updatePrices() {
        try {
          // Fetch SOL price from CoinGecko
          const solPriceResponse = await axios.get("https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd");
          const newSolPrice = solPriceResponse.data.solana?.usd || 0;

          // Simulate FIXR price (replace with real API if available)
          const baseFixrPrice = 0.005;
          const fluctuation = (Math.random() - 0.5) * 0.0001;
          const newFixrPrice = Math.max(0.0001, tokens[1].price === 0 ? baseFixrPrice : tokens[1].price + fluctuation);

          // Update token prices and history
          tokens[0].price = newSolPrice;
          tokens[1].price = newFixrPrice;

          const now = Date.now();
          tokens.forEach(token => {
            token.priceHistory.push({ time: now, price: token.price });
            if (token.priceHistory.length > 288) { // Keep roughly 24 hours of data
              token.priceHistory.shift();
            }
            if (token.hasChart) {
              updateChart(token);
            }
          });

          updateTokenDisplays();
          updateTotalBalance();
          checkSignals();
        } catch (error) {
          console.error("Error fetching prices:", error);
          tokens.forEach(token => token.price = 0);
          updateTokenDisplays();
          updateTotalBalance();
        }
      }

      function updateChart(token) {
        if (!token.chart) return;

        const dataPoints = token.priceHistory;
        const labels = dataPoints.map(p => new Date(p.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
        const prices = dataPoints.map(p => p.price);

        token.chart.data.labels = labels;
        token.chart.data.datasets[0].data = prices;
        token.chart.update();
      }

      // --- Signal Logic ---
      function checkSignals() {
        tokens.forEach(token => {
          const existingSignal = document.querySelector(`.signal-${token.symbol}`);
          if (existingSignal) existingSignal.remove();

          if (token.priceHistory.length < 2) return;

          const latestPrice = token.priceHistory[token.priceHistory.length - 1].price;
          const fiveMinAgoPrice = token.priceHistory.find(p => Date.now() - p.time > 5 * 60 * 1000)?.price || token.priceHistory[0].price;

          if (fiveMinAgoPrice === 0) return;

          const percentChange = ((latestPrice - fiveMinAgoPrice) / fiveMinAgoPrice) * 100;          if (percentChange >= 2) {
            addSignalIndicator(token.symbol, 'BUY');
          } else if (percentChange <= -2) {
            addSignalIndicator(token.symbol, 'SELL');
          }
        });
      }

      function addSignalIndicator(symbol, type) {
        const tokenCard = document.querySelector(`.token-card-${symbol}`);
        if (!tokenCard) return;        const indicator = document.createElement('div');
        indicator.className = `signal-indicator ${type.toLowerCase()}-signal signal-${symbol}`;
        indicator.textContent = type;
        tokenCard.appendChild(indicator);
      }

      // --- Total Balance Display ---
      function updateTotalBalance() {
        let total = 0;
        tokens.forEach(token => {
          const bal = token.balance || 0;
          const price = token.price || 0;
          total += bal * price;
        });
        elements.totalBalance.textContent = `Total Balance: $${formatNumber(total, 2)}`;
      }

      // --- UI Rendering ---
      function renderTokens() {
        elements.tokensContainer.innerHTML = ''; // Clear existing content

        tokens.forEach(token => {
          const tokenCard = document.createElement('div');
          tokenCard.className = `token-card token-card-${token.symbol} ${token.isCompact ? 'compact' : ''}`;
          tokenCard.setAttribute('aria-live', 'polite');
          tokenCard.setAttribute('aria-atomic', 'true');

          // Header: Symbol & Price Info
          const header = document.createElement('div');
          header.className = 'token-header';

          const symbolEl = document.createElement('div');
          symbolEl.className = 'token-symbol';
          symbolEl.textContent = token.symbol;

          const priceInfo = document.createElement('div');
          priceInfo.className = 'token-price-info';

          const priceEl = document.createElement('span');
          priceEl.className = 'token-price';
          priceEl.textContent = `$${formatNumber(token.price, 6)}`;

          const priceChangeEl = document.createElement('span');
          priceChangeEl.className = 'price-change';
          priceChangeEl.textContent = '0.00%'; // Initial value

          priceInfo.appendChild(priceEl);
          priceInfo.appendChild(priceChangeEl);
          header.appendChild(symbolEl);
          header.appendChild(priceInfo);
          tokenCard.appendChild(header);

          // Balance
          const balanceEl = document.createElement('div');
          balanceEl.className = 'token-balance';
          balanceEl.textContent = state.walletConnected ? formatNumber(token.balance, 4) : 'Connect Wallet';
          tokenCard.appendChild(balanceEl);

          // Chart (only for SOL)
          if (token.hasChart) {
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            const canvas = document.createElement('canvas');
            canvas.className = 'price-chart';
            chartContainer.appendChild(canvas);
            tokenCard.appendChild(chartContainer);

            // Initialize Chart.js
            const ctx = canvas.getContext('2d');
            token.chart = new ChartJS(ctx, {
              type: 'line',
              data: {
                labels: [],
                datasets: [{
                  label: `${token.symbol} Price`,
                  data: [],
                  borderColor: '#00ffa8',
                  backgroundColor: 'rgba(0, 255, 168, 0.1)',
                  fill: true,
                  pointRadius: 0,
                  borderWidth: 2,
                  tension: 0.25,
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                scales: {
                  x: { display: false },
                  y: { display: false, beginAtZero: false }
                },
                plugins: {                  legend: { display: false },
                  tooltip: { enabled: false },
                },
                elements: { line: { borderJoinStyle: 'round' } },
                layout: {
                  padding: { left: 0, right: 0, top: 0, bottom: 0 }
                }
              }
            });
            updateChart(token); // Initial chart update
          }

          // Buy/Sell buttons on cards
          const tokenActions = document.createElement('div');
          tokenActions.className = 'token-actions';
          const buyBtn = document.createElement('button');
          buyBtn.className = 'token-action-btn';
          buyBtn.textContent = 'Buy';
          buyBtn.disabled = !state.walletConnected;
          buyBtn.onclick = () => openExchangeModal(token.symbol, 'buy');

          const sellBtn = document.createElement('button');          sellBtn.className = 'token-action-btn';
          sellBtn.textContent = 'Sell';
          sellBtn.disabled = !state.walletConnected;
          sellBtn.onclick = () => openExchangeModal(token.symbol, 'sell');

          tokenActions.appendChild(buyBtn);
          tokenActions.appendChild(sellBtn);
          tokenCard.appendChild(tokenActions);

          elements.tokensContainer.appendChild(tokenCard);
        });
      }

      // Update token balance and price displays
      function updateTokenDisplays() {
        tokens.forEach(token => {
          const card = document.querySelector(`.token-card-${token.symbol}`);
          if (!card) return;

          const balanceEl = card.querySelector('.token-balance');
          if (balanceEl) {
            balanceEl.textContent = state.walletConnected ? formatNumber(token.balance, 4) : 'Connect Wallet';
          }

          const priceEl = card.querySelector('.token-price');
          if (priceEl) {
            priceEl.textContent = `$${formatNumber(token.price, 6)}`;
          }

          const priceChangeEl = card.querySelector('.price-change');
          if (priceChangeEl && token.priceHistory.length > 1) {
            const initialPrice = token.priceHistory[0].price;
            if (initialPrice !== 0) {
              const change = ((token.price - initialPrice) / initialPrice) * 100;
              priceChangeEl.textContent = `${change > 0 ? '+' : ''}${change.toFixed(2)}%`;
              priceChangeEl.className = `price-change ${change >= 0 ? 'price-up' : 'price-down'}`;
            } else {
              priceChangeEl.textContent = 'N/A';
              priceChangeEl.className = 'price-change';
            }
          }

          // Update buy/sell button disabled state
          const buyBtn = card.querySelector('.token-action-btn:nth-child(1)');
          const sellBtn = card.querySelector('.token-action-btn:nth-child(2)');          if (buyBtn) buyBtn.disabled = !state.walletConnected;
          if (sellBtn) sellBtn.disabled = !state.walletConnected;
        });
      }

      // --- Modal Functions ---
      function openModal(type, data = null) {
        state.modal = { isOpen: true, type, data };
        state.modalStatus = null;
        state.modalError = null;
        state.modalLoading = false;
        renderModal();
      }

      function closeModal() {
        state.modal = { isOpen: false, type: null, data: null };
        state.modalStatus = null;
        state.modalError = null;
        state.modalLoading = false;
        renderModal();
      }

      function renderModal() {
        let modalHtml = '';
        if (state.modal.isOpen) {          let modalContent = '';
          let modalTitle = '';

          switch (state.modal.type) {
            case 'deposit':
              modalTitle = 'Deposit SOL';
              modalContent = `
                <p>Send SOL to your wallet address:</p>
                <div style="font-family: monospace; word-break: break-all; background: #0e1217; padding: 10px; border-radius: 5px; margin-bottom: 15px;">
                  ${state.publicKey?.toBase58() || 'Connect wallet to see address'}
                </div>
                <div id="qrcodeCanvas" style="text-align: center; margin-bottom: 15px;"></div>
                <button onclick="navigator.clipboard.writeText('${state.publicKey?.toBase58() || ''}'); alert('Address copied!');" style="background: #00cc7a; color: #111; padding: 10px; border: none; border-radius: 5px; cursor: pointer;">Copy Address</button>
              `;
              break;
            case 'withdraw':
              modalTitle = 'Withdraw SOL';
              modalContent = `
                <form id="withdrawForm" class="modal-form">
                  <label for="withdrawAmount">Amount (SOL):</label>                  <input type="number" id="withdrawAmount" step="0.000001" min="0" placeholder="0.00" required />
                  <label for="withdrawRecipient">Recipient Address:</label>
                  <input type="text" id="withdrawRecipient" placeholder="Solana address" required />
                  <button type="submit" ${state.modalLoading ? 'disabled' : ''}>${state.modalLoading ? 'Processing...' : 'Withdraw'}</button>
                </form>
              `;
              break;
            case 'exchange':
              const targetToken = state.modal.data.tokenSymbol;
              const actionType = state.modal.data.actionType;
              const inputToken = actionType === 'buy' ? 'SOL' : targetToken;
              const outputToken = actionType === 'buy' ? targetToken : 'SOL';
              const inputBalance = tokens.find(t => t.symbol === inputToken)?.balance || 0;

              modalTitle = `${actionType === 'buy' ? 'Buy' : 'Sell'} ${targetToken}`;
              modalContent = `
                <form id="exchangeForm" class="modal-form">
                  <label for="exchangeAmount">Amount (${inputToken}):</label>
                  <input type="number" id="exchangeAmount" step="0.000001" min="0" placeholder="0.00" required />
                  <p style="font-size: 0.85rem; color: #aaa; margin-top: -10px; margin-bottom: 15px;">
                    Your ${inputToken} balance: ${formatNumber(inputBalance, 4)}
                  </p>
                  <p style="font-size: 0.85rem; color: #ddd;">
                    Exchanging ${inputToken} for ${outputToken}.
                  </p>
                  <button type="submit" ${state.modalLoading ? 'disabled' : ''}>${state.modalLoading ? 'Processing...' : `Confirm ${actionType}`}</button>
                </form>
              `;
              break;
          }

          modalHtml = `
            <div class="modal-overlay">
              <div class="modal-content">
                <div class="modal-header">
                  <h2>${modalTitle}</h2>
                  <button class="modal-close-btn" onclick="closeModal()">×</button>
                </div>
                ${modalContent}                ${state.modalLoading ? '<div class="modal-loader"><div class="loading"></div></div>' : ''}
                ${state.modalStatus ? `<div class="modal-status">${state.modalStatus}</div>` : ''}                ${state.modalError ? `<div class="modal-error">${state.modalError}</div>` : ''}
              </div>
            </div>
          `;
        }

        let modalRoot = document.getElementById('modal-root');
        if (!modalRoot) {
          modalRoot = document.createElement('div');
          modalRoot.id = 'modal-root';
          document.body.appendChild(modalRoot);
        }        modalRoot.innerHTML = modalHtml;

        if (state.modal.isOpen) {
          if (state.modal.type === 'deposit' && state.publicKey) {
            const qrCodeCanvas = document.getElementById('qrcodeCanvas');
            if (qrCodeCanvas) {
              QRCode.toCanvas(qrCodeCanvas, state.publicKey.toBase58(), { width: 150 }, function (error) {
                if (error) console.error('QR Code error:', error);
              });
            }
          } else if (state.modal.type === 'withdraw') {
            document.getElementById('withdrawForm')?.addEventListener('submit', handleWithdraw);
          } else if (state.modal.type === 'exchange') {
            document.getElementById('exchangeForm')?.addEventListener('submit', handleExchange);
          }
        }
      }

      // --- Deposit/Withdraw/Exchange Handlers ---
      async function handleWithdraw(event) {
        event.preventDefault();
        if (!state.walletConnected || !state.publicKey) {
          state.modalError = "Wallet not connected.";
          renderModal();
          return;
        }

        const amountInput = document.getElementById('withdrawAmount');
        const recipientInput = document.getElementById('withdrawRecipient');
        const amount = parseFloat(amountInput.value);
        const recipientAddress = recipientInput.value;

        if (isNaN(amount) || amount <= 0) {
          state.modalError = "Please enter a valid amount.";
          renderModal();
          return;
        }
        if (!recipientAddress) {
          state.modalError = "Please enter a recipient address.";
          renderModal();
          return;
        }

        try {
          const recipientPubKey = new solanaWeb3.PublicKey(recipientAddress);
          const solToken = tokens[0];
          if (amount > solToken.balance) {
            state.modalError = `Insufficient SOL balance. Available: ${formatNumber(solToken.balance, 4)}`;
            renderModal();
            return;
          }

          state.modalLoading = true;
          state.modalError = null;
          state.modalStatus = null;
          renderModal();

          const lamports = toBaseUnits(amount, solToken.decimals);
          const transaction = new solanaWeb3.Transaction().add(
            solanaWeb3.SystemProgram.transfer({
              fromPubkey: state.publicKey,
              toPubkey: recipientPubKey,
              lamports: lamports,
            })
          );

          const { blockhash, lastValidBlockHeight } = await state.connection.getLatestBlockhash();
          transaction.recentBlockhash = blockhash;
          transaction.lastValidBlockHeight = lastValidBlockHeight;
          transaction.feePayer = state.publicKey;

          const signedTransaction = await state.provider.signTransaction(transaction);
          const signature = await state.connection.sendRawTransaction(signedTransaction.serialize());

          state.modalStatus = `Transaction sent: ${signature}`;
          await state.connection.confirmTransaction({
            blockhash,
            lastValidBlockHeight,            signature
          });
          state.modalStatus = `Withdrawal successful! Transaction: ${signature}`;
          await fetchBalances(); // Refresh balances
        } catch (err) {
          console.error("Withdrawal failed:", err);
          state.modalError = `Withdrawal failed: ${err.message || 'Unknown error'}`;
        } finally {
          state.modalLoading = false;
          renderModal();
        }      }

      async function handleExchange(event) {
        event.preventDefault();
        if (!state.walletConnected || !state.publicKey) {
          state.modalError = "Wallet not connected.";
          renderModal();
          return;
        }

        const amountInput = document.getElementById('exchangeAmount');
        const inputAmount = parseFloat(amountInput.value);
        if (isNaN(inputAmount) || inputAmount <= 0) {
          state.modalError = "Please enter a valid amount.";
          renderModal();
          return;
        }

        const targetTokenSymbol = state.modal.data.tokenSymbol;
        const actionType = state.modal.data.actionType; // 'buy' or 'sell'

        const inputToken = actionType === 'buy' ? tokens.find(t => t.symbol === 'SOL') : tokens.find(t => t.symbol === targetTokenSymbol);
        const outputToken = actionType === 'buy' ? tokens.find(t => t.symbol === targetTokenSymbol) : tokens.find(t => t.symbol === 'SOL');

        if (!inputToken || !outputToken) {
          state.modalError = "Invalid tokens for exchange.";
          renderModal();
          return;
        }

        if (inputAmount > inputToken.balance) {
          state.modalError = `Insufficient ${inputToken.symbol} balance. Available: ${formatNumber(inputToken.balance, 4)}`;
          renderModal();
          return;
        }

        state.modalLoading = true;
        state.modalError = null;
        state.modalStatus = null;
        renderModal();

        try {
          const amountInLamports = toBaseUnits(inputAmount, inputToken.decimals);          // Step 1: Get quote from Jupiter Aggregator
          const quoteResponse = await axios.get(`https://quote-api.jup.ag/v6/quote?inputMint=${inputToken.mint}&outputMint=${outputToken.mint}&amount=${amountInLamports}&slippageBps=50`); // 0.5% slippage
          const route = quoteResponse.data.routes[0];

          if (!route) {
            throw new Error("No swap route found for this pair/amount.");
          }

          state.modalStatus = `Estimated ${outputToken.symbol} output: ${fromBaseUnits(route.outAmount, outputToken.decimals).toFixed(outputToken.decimals)} ${outputToken.symbol}`;
          renderModal();

          // Step 2: Get swap transaction from Jupiter
          const swapResponse = await axios.post('https://quote-api.jup.ag/v6/swap', {
            quoteResponse: route,
            userPublicKey: state.publicKey.toBase58(),
            wrapUnwrapSOL: true, // Automatically wrap/unwrap SOL if needed
          });

          const { swapTransaction } = swapResponse.data;
          const transactionBuf = Buffer.from(swapTransaction, 'base64');
          const transaction = solanaWeb3.Transaction.from(transactionBuf);

          // Step 3: Sign and send transaction via Phantom
          const signedTransaction = await state.provider.signTransaction(transaction);
          const signature = await state.connection.sendRawTransaction(signedTransaction.serialize());

          state.modalStatus = `Transaction sent: ${signature}`;
          await state.connection.confirmTransaction({
            blockhash: transaction.recentBlockhash,
            lastValidBlockHeight: transaction.lastValidBlockHeight,
            signature
          });

          state.modalStatus = `Exchange successful! Transaction: ${signature}`;
          await fetchBalances(); // Refresh balances
        } catch (err) {
          console.error("Exchange failed:", err);
          state.modalError = `Exchange failed: ${err.response?.data?.error || err.message || 'Unknown error'}`;
        } finally {
          state.modalLoading = false;
          renderModal();
        }
      }

      // --- Initial Setup ---
      function initializeApp() {
        // Initial UI render (disconnected state)
        updateUI();
        renderTokens();
        updateTotalBalance(); // Show 0.00 initially

        // Set up event listeners for main buttons
        elements.connectBtn.addEventListener("click", connectWallet);
        elements.disconnectBtn.addEventListener("click", disconnectWallet);
        elements.depositBtn.addEventListener("click", () => openModal('deposit'));
        elements.withdrawBtn.addEventListener("click", () => openModal('withdraw'));
        elements.exchangeBtn.addEventListener("click", () => alert("Please use the 'Buy' or 'Sell' buttons on the token cards for exchange.")); // General exchange button

        // Handle external Phantom disconnects (do NOT auto-disconnect our UI state)
        if (state.provider) {
          state.provider.on('disconnect', () => {
            console.log("Phantom wallet disconnected externally. UI remains connected until explicit disconnect.");
          });
        }

        // Start periodic data updates
        updatePrices(); // Initial price fetch
        state.priceUpdateInterval = setInterval(updatePrices, 30000); // Update prices every 30 seconds

        fetchBalances(); // Initial balance fetch (will be 0 if disconnected)
        state.balanceUpdateInterval = setInterval(fetchBalances, 10000); // Update balances every 10 seconds
      }

      // Run initialization when DOM is ready
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeApp);
      } else {
        initializeApp();
      }

      // Expose functions to global scope for onclick attributes in modals
      window.closeModal = closeModal;
      window.openExchangeModal = (tokenSymbol, actionType) => openModal('exchange', { tokenSymbol, actionType });
      window.handleWithdraw = handleWithdraw;
      window.handleExchange = handleExchange;

    })();
  </script>
</body>
</html>

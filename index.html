 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>FIXORIUM WALLET</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.2/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Reset & base styles */
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #111;
      color: #fff;
      font-family: Arial, sans-serif;
      font-size: 13px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      user-select: none;
      overflow: hidden; /* Prevent scroll on main body */
    }

    /* Full screen layout */
    #app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* Header styles */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #181818;
      padding: 8px 12px;
      box-shadow: 0 2px 8px #00ffa833;
      flex-shrink: 0;
    }

    #logo-left {
      font-size: 1.2rem;
      font-weight: 700;
      color: #00ffa8;
      letter-spacing: 0.02em;
      user-select: text;
    }

    #wallet-row {
      display: flex;
      gap: 7px;
      align-items: center;
      min-width: 200px;
      justify-content: end;
      flex-wrap: nowrap;
    }

    #connectWalletBtn,
    #disconnectWalletBtn {
      background: #00ffa8;
      border: none;
      color: #111;
      font-weight: 700;
      padding: 5px 18px;
      border-radius: 6px;
      cursor: pointer;
      min-width: 90px;
      font-size: 13px;
      white-space: nowrap;
      user-select: none;
      text-transform: uppercase;
      box-shadow: 0 1px 8px #00ffa844;
      transition: background 0.2s ease;
      flex-shrink: 0;
    }

    #connectWalletBtn:hover,
    #disconnectWalletBtn:hover {
      background: #00cc7a;
      color: #121212;
    }

    #disconnectWalletBtn {
      background: transparent;
      border: 1.5px solid #00ffa8;
      color: #00ffa8;    }

    #walletAddress {
      font-size: 13px;
      color: #00ffa8;
      letter-spacing: 0.03em;
      font-weight: 600;
      user-select: text;
      white-space: nowrap;
      max-width: 130px;
      overflow: hidden;
      text-overflow: ellipsis;    }

    /* Main content area - tokens */
    .tokens-container {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 1fr; /* Two columns for tokens */
      gap: 10px;
      padding: 10px;
      overflow: hidden; /* Prevent container scroll if content is too large */
    }

    .token-card {
      background: #181c22;
      border-radius: 10px;
      box-shadow: 0 1px 8px #00ffa833 inset;
      display: flex;
      flex-direction: column;
      padding: 12px;
      height: calc(100% - 24px); /* Account for padding */
      position: relative;
      transition: box-shadow 0.10s ease, transform 0.15s ease;
      overflow: hidden; /* Ensure content within card doesn't overflow */
    }

    .token-card:hover {
      box-shadow: 0 1px 14px #00ffa8cc inset;
      transform: scale(1.01);
    }

    .token-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .token-symbol {
      font-weight: 700;
      font-size: 16px;
      color: #00ffaa;
      letter-spacing: 0.07em;
    }

    .token-price-info {
      display: flex;
      align-items: baseline;
      gap: 5px;
    }

    .token-price {
      font-size: 14px;
      color: #fff;
      font-weight: 600;
    }

    .token-balance {
      font-size: 24px;
      font-weight: bold;
      margin: 10px 0;
      color: #00ff99;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .price-change {
      font-size: 12px;
      padding: 3px 6px;
      border-radius: 4px;
      font-weight: bold;
    }

    .price-up {
      background-color: rgba(22, 199, 132, 0.2);
      color: #16c784;
    }

    .price-down {
      background-color: rgba(234, 57, 67, 0.2);
      color: #ea3943;
    }

    .chart-container {
      flex: 1; /* Make chart container fill remaining space */
      min-height: 80px; /* Minimum height for chart */
      margin-top: 10px;
      overflow: hidden; /* Important for Chart.js responsiveness */
      position: relative;
    }
    .price-chart {
      width: 100% !important;
      height: 100% !important;
      max-height: unset !important; /* Override Chart.js inline style */
    }

    /* Action buttons at bottom */
    .action-buttons {
      display: flex;
      justify-content: space-around;
      padding: 10px;
      background: #181818;      border-top: 1px solid #00ffa833;
      flex-shrink: 0;
    }

    .action-btn {
      background: #00ffa8;
      border: none;
      color: #111;
      font-weight: 700;
      padding: 12px 0;
      border-radius: 8px;
      font-size: 15px;
      cursor: pointer;
      transition: background 0.25s ease;
      width: 30%; /* Distribute width evenly */
      text-align: center;
      text-transform: uppercase;
      box-shadow: 0 3px 10px #00ffa833;
    }

    .action-btn:hover {
      background: #00cc7a;
    }

    .action-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* Signal indicators */
    .signal-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: bold;
      text-transform: uppercase;
      animation: blinky 0.75s steps(1) infinite;
      z-index: 10; /* Ensure it's above other elements */
    }

    .buy-signal {
      background-color: rgba(22, 199, 132, 0.2);
      color: #16c784;
      border: 1px solid #16c784;
    }

    .sell-signal {
      background-color: rgba(234, 57, 67, 0.2);
      color: #ea3943;
      border: 1px solid #ea3943;
    }

    @keyframes blinky {      0% { opacity: 1; }
      50% { opacity: 0.35; }
      100% { opacity: 1; }
    }

    /* Loading state */    .loading {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: #00ffa8;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Media queries for smaller screens */
    @media (max-width: 768px) {
      .tokens-container {
        grid-template-columns: 1fr; /* Single column on smaller screens */
      }
    }
  </style>
</head>
<body>
  <div id="app-container">
    <header>
      <div id="logo-left">FIXORIUM WALLET</div>
      <div id="wallet-row">
        <button id="connectWalletBtn">CONNECT</button>
        <button id="disconnectWalletBtn" style="display:none;">DISCONNECT</button>
        <span id="walletAddress"></span>
      </div>
    </header>

    <div class="tokens-container" id="tokensContainer">
      <!-- Tokens will be rendered here -->
    </div>

    <div class="action-buttons">
      <button id="depositBtn" class="action-btn" disabled>Deposit</button>
      <button id="withdrawBtn" class="action-btn" disabled>Withdraw</button>
      <button id="exchangeBtn" class="action-btn">Exchange</button>
    </div>
  </div>

  <script>    (() => {
      const solanaWeb3 = window.solanaWeb3;
      const ChartJS = window.Chart;

      // Token configuration and state
      const tokens = [
        {
          symbol: "SOL",          name: "Solana",
          mint: null, // SOL is native coin, no mint address
          decimals: 9,
          price: 0,
          balance: 0,
          priceHistory: [], // Stores {time, price} for chart
          chart: null // Chart.js instance
        },
        {
          symbol: "FIXR",
          name: "Fixercoin",
          mint: "D2mGkp5D43jirFeapx8UZmpiH7FaWeX1eUWy94q1F2hD", // FIXERCOIN mint address
          decimals: 9,
          price: 0,
          balance: 0,
          priceHistory: [],
          chart: null
        }
      ];

      // Global app state
      const state = {
        walletConnected: false,
        publicKey: null,
        provider: window.solana?.isPhantom ? window.solana : null,
        connection: new solanaWeb3.Connection(solanaWeb3.clusterApiUrl("mainnet-beta"), "confirmed"),
        priceUpdateInterval: null,
        balanceUpdateInterval: null
      };

      // DOM elements cache
      const elements = {
        connectBtn: document.getElementById("connectWalletBtn"),
        disconnectBtn: document.getElementById("disconnectWalletBtn"),
        walletAddress: document.getElementById("walletAddress"),
        tokensContainer: document.getElementById("tokensContainer"),
        depositBtn: document.getElementById("depositBtn"),
        withdrawBtn: document.getElementById("withdrawBtn"),
        exchangeBtn: document.getElementById("exchangeBtn")
      };

      // Utility: Format number nicely
      function formatNumber(num, decimals = 4) {
        if (typeof num !== "number" || isNaN(num)) return "-";
        return num.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: decimals });
      }

      // Utility: Find Associated Token Account (ATA)
      async function findATA(walletAddress, tokenMintAddress) {
        return (await solanaWeb3.PublicKey.findProgramAddress(
          [
            walletAddress.toBuffer(),
            solanaWeb3.TOKEN_PROGRAM_ID.toBuffer(),
            tokenMintAddress.toBuffer(),
          ],
          solanaWeb3.ASSOCIATED_TOKEN_PROGRAM_ID
        ))[0];
      }

      // --- Wallet Connection Logic ---
      function updateUI() {
        if (state.walletConnected && state.publicKey) {
          elements.connectBtn.style.display = "none";
          elements.disconnectBtn.style.display = "";
          elements.depositBtn.disabled = false;
          elements.withdrawBtn.disabled = false;
          
          let addrStr = state.publicKey.toBase58();
          addrStr = addrStr.length > 10 ? addrStr.slice(0, 6) + "..." + addrStr.slice(-4) : addrStr;
          elements.walletAddress.textContent = addrStr;
        } else {
          elements.connectBtn.style.display = "";
          elements.disconnectBtn.style.display = "none";
          elements.depositBtn.disabled = true;
          elements.withdrawBtn.disabled = true;
          elements.walletAddress.textContent = "";        }
        updateTokenDisplays(); // Ensure token balances reflect connection state
      }

      async function connectWallet() {
        if (!state.provider) {
          alert("Phantom Wallet not found. Please install it to connect.");
          window.open("https://phantom.app/", "_blank"); // Open Phantom download page
          return;
        }

        try {
          // Request connection permission from user
          const response = await state.provider.connect({ onlyIfTrusted: false });
          state.publicKey = response.publicKey;
          state.walletConnected = true;
          updateUI();
          fetchBalances(); // Fetch balances immediately after connection
        } catch (error) {
          console.error("Wallet connection rejected or failed:", error);
          alert("Wallet connection was rejected or an error occurred.");
        }
      }

      async function disconnectWallet() {
        if (state.provider && state.walletConnected) {
          try {
            await state.provider.disconnect();
          } catch (error) {
            console.error("Error during Phantom disconnect:", error);
            // Even if disconnect fails, we update our internal state
          }
        }
        
        state.walletConnected = false;
        state.publicKey = null;
        // Reset balances in UI
        tokens.forEach(token => {
          token.balance = 0;
        });
        updateUI();
      }

      // --- Balance Fetching ---
      async function fetchBalances() {
        // If not connected, balances are zero. Don't throw errors.
        if (!state.walletConnected || !state.publicKey) {
          tokens.forEach(token => token.balance = 0);
          updateTokenDisplays();
          return;
        }

        try {
          // Fetch SOL balance
          const solBalanceRaw = await state.connection.getBalance(state.publicKey);
          tokens[0].balance = solBalanceRaw / (10 ** tokens[0].decimals);

          // Fetch FIXR balance
          const fixrToken = tokens[1];
          if (fixrToken.mint) {
            try {
              const fixrMintPubKey = new solanaWeb3.PublicKey(fixrToken.mint);
              const ata = await findATA(state.publicKey, fixrMintPubKey);
              const accountInfo = await state.connection.getParsedAccountInfo(ata);
              if (accountInfo.value?.data?.parsed?.info?.tokenAmount) {
                fixrToken.balance = accountInfo.value.data.parsed.info.tokenAmount.uiAmount;
              } else {
                fixrToken.balance = 0; // Account doesn't exist or has no tokens
              }
            } catch (ataError) {
              console.warn(`Could not get ATA for ${fixrToken.symbol}:`, ataError);
              fixrToken.balance = 0; // Assume 0 if ATA lookup fails
            }
          }
          updateTokenDisplays(); // Update UI after fetching balances
        } catch (error) {
          console.error("Failed to fetch balances:", error);
          // If connection error, reset balances to 0 in UI
          tokens.forEach(token => token.balance = 0);
          updateTokenDisplays();
        }
      }

      // --- Price Fetching and Chart Updates ---
      async function updatePrices() {
        try {
          // Fetch SOL price from CoinGecko
          const solPriceResponse = await axios.get("https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd");
          const newSolPrice = solPriceResponse.data.solana?.usd || 0;
          
          // Simulate FIXR price for demonstration (replace with real API if available)
          // Make FIXR price fluctuate slightly around a base value, e.g., 0.005
          const baseFixrPrice = 0.005;
          const fluctuation = (Math.random() - 0.5) * 0.0001; // +/- 0.00005
          const newFixrPrice = Math.max(0.0001, tokens[1].price === 0 ? baseFixrPrice : tokens[1].price + fluctuation);

          // Update token prices and history
          tokens[0].price = newSolPrice;
          tokens[1].price = newFixrPrice;

          const now = Date.now();
          tokens.forEach(token => {
            token.priceHistory.push({ time: now, price: token.price });
            // Keep roughly 24 hours of data (288 points if updated every 5 mins)
            if (token.priceHistory.length > 288) {
              token.priceHistory.shift();
            }
            updateChart(token); // Update the chart
          });
          
          updateTokenDisplays(); // Update price display
          checkSignals(); // Re-evaluate signals
        } catch (error) {
          console.error("Error fetching prices:", error);
          // Set prices to 0 or null if API fails
          tokens.forEach(token => token.price = 0);
          updateTokenDisplays();
        }
      }

      function updateChart(token) {
        if (!token.chart) return; // Chart not initialized yet

        const dataPoints = token.priceHistory;
        const labels = dataPoints.map(p => new Date(p.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
        const prices = dataPoints.map(p => p.price);

        token.chart.data.labels = labels;
        token.chart.data.datasets[0].data = prices;
        token.chart.update();
      }

      // --- Signal Logic ---
      function checkSignals() {
        tokens.forEach(token => {
          // Remove previous signal
          const existingSignal = document.querySelector(`.signal-${token.symbol}`);
          if (existingSignal) existingSignal.remove();

          if (token.priceHistory.length < 2) return; // Need at least two points to compare

          // Simple signal: 5-minute price change
          const latestPrice = token.priceHistory[token.priceHistory.length - 1].price;
          const fiveMinAgoPrice = token.priceHistory.find(p => Date.now() - p.time > 5 * 60 * 1000)?.price || token.priceHistory[0].price;

          if (fiveMinAgoPrice === 0) return; // Avoid division by zero

          const percentChange = ((latestPrice - fiveMinAgoPrice) / fiveMinAgoPrice) * 100;

          if (percentChange >= 2) { // 2% up in 5 minutes
            addSignalIndicator(token.symbol, 'BUY');
          } else if (percentChange <= -2) { // 2% down in 5 minutes
            addSignalIndicator(token.symbol, 'SELL');
          }
        });
      }

      function addSignalIndicator(symbol, type) {
        const tokenCard = document.querySelector(`.token-card-${symbol}`);
        if (!tokenCard) return;

        const indicator = document.createElement('div');
        indicator.className = `signal-indicator ${type.toLowerCase()}-signal signal-${symbol}`;
        indicator.textContent = type;
        tokenCard.appendChild(indicator);
      }

      // --- UI Rendering ---
      function renderTokens() {
        elements.tokensContainer.innerHTML = ''; // Clear existing content

        tokens.forEach(token => {
          const tokenCard = document.createElement('div');
          tokenCard.className = `token-card token-card-${token.symbol}`;
          tokenCard.setAttribute('aria-live', 'polite');
          tokenCard.setAttribute('aria-atomic', 'true');

          // Header: Symbol & Price Info
          const header = document.createElement('div');
          header.className = 'token-header';

          const symbolEl = document.createElement('div');
          symbolEl.className = 'token-symbol';
          symbolEl.textContent = token.symbol;

          const priceInfo = document.createElement('div');
          priceInfo.className = 'token-price-info';

          const priceEl = document.createElement('span');
          priceEl.className = 'token-price';
          priceEl.textContent = `$${formatNumber(token.price, 6)}`;

          const priceChangeEl = document.createElement('span');
          priceChangeEl.className = 'price-change';
          priceChangeEl.textContent = '0.00%'; // Initial value
          
          priceInfo.appendChild(priceEl);
          priceInfo.appendChild(priceChangeEl);
          header.appendChild(symbolEl);
          header.appendChild(priceInfo);
          tokenCard.appendChild(header);

          // Balance
          const balanceEl = document.createElement('div');
          balanceEl.className = 'token-balance';
          balanceEl.textContent = state.walletConnected ? formatNumber(token.balance, 4) : 'Connect Wallet';
          tokenCard.appendChild(balanceEl);

          // Chart Container
          const chartContainer = document.createElement('div');
          chartContainer.className = 'chart-container';
          const canvas = document.createElement('canvas');
          canvas.className = 'price-chart';
          chartContainer.appendChild(canvas);
          tokenCard.appendChild(chartContainer);

          elements.tokensContainer.appendChild(tokenCard);          // Initialize Chart.js
          const ctx = canvas.getContext('2d');
          token.chart = new ChartJS(ctx, {
            type: 'line',
            data: {
              labels: [],
              datasets: [{
                label: `${token.symbol} Price`,
                data: [],
                borderColor: '#00ffa8',
                backgroundColor: 'rgba(0, 255, 168, 0.1)',
                fill: true,
                pointRadius: 0,
                borderWidth: 2,
                tension: 0.25,
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: false,
              scales: {
                x: { display: false },
                y: { display: false, beginAtZero: false }
              },
              plugins: {                legend: { display: false },
                tooltip: { enabled: false },
              },
              elements: { line: { borderJoinStyle: 'round' } },
              layout: {
                padding: {                  left: 0, right: 0, top: 0, bottom: 0
                }
              }
            }
          });
          updateChart(token); // Initial chart update
        });
      }

      // Update token balance and price displays
      function updateTokenDisplays() {
        tokens.forEach(token => {
          const card = document.querySelector(`.token-card-${token.symbol}`);
          if (!card) return; // Card not rendered yet

          const balanceEl = card.querySelector('.token-balance');
          if (balanceEl) {
            balanceEl.textContent = state.walletConnected ? formatNumber(token.balance, 4) : 'Connect Wallet';
          }

          const priceEl = card.querySelector('.token-price');
          if (priceEl) {
            priceEl.textContent = `$${formatNumber(token.price, 6)}`;
          }

          const priceChangeEl = card.querySelector('.price-change');
          if (priceChangeEl && token.priceHistory.length > 1) {
            const initialPrice = token.priceHistory[0].price;            if (initialPrice !== 0) {
              const change = ((token.price - initialPrice) / initialPrice) * 100;
              priceChangeEl.textContent = `${change > 0 ? '+' : ''}${change.toFixed(2)}%`;
              priceChangeEl.className = `price-change ${change >= 0 ? 'price-up' : 'price-down'}`;
            } else {
              priceChangeEl.textContent = 'N/A';
              priceChangeEl.className = 'price-change';
            }
          }
        });
      }

      // --- Modal Functions (Placeholders) ---
      function showDepositModal() {        if (!state.walletConnected || !state.publicKey) {
          alert("Please connect your wallet to deposit.");
          return;
        }
        alert(`Deposit SOL to address: ${state.publicKey.toBase58()}\n(Functionality to be implemented)`);
      }

      function showWithdrawModal() {
        if (!state.walletConnected || !state.publicKey) {
          alert("Please connect your wallet to withdraw.");
          return;
        }
        alert(`Withdraw SOL from address: ${state.publicKey.toBase58()}\n(Functionality to be implemented)`);
      }

      function showExchangeModal() {
        alert("Exchange functionality using Pump.fun modules will be implemented here.\n(This would involve integrating with the Pump.fun API for buying/selling tokens)");
        // Example: You would open a modal with input fields for amount, from/to tokens,
        // then call Pump.fun APIs or a Jupiter Aggregator API to perform the swap.
      }

      // --- Initialization ---
      function initializeApp() {
        updateUI(); // Set initial UI state (disconnected)
        renderTokens(); // Render token cards with initial data

        // Set up event listeners for buttons
        elements.connectBtn.addEventListener("click", connectWallet);
        elements.disconnectBtn.addEventListener("click", disconnectWallet);        elements.depositBtn.addEventListener("click", showDepositModal);
        elements.withdrawBtn.addEventListener("click", showWithdrawModal);
        elements.exchangeBtn.addEventListener("click", showExchangeModal);

        // Handle external Phantom disconnects (do NOT auto-disconnect our UI)
        if (state.provider) {
          state.provider.on('disconnect', () => {
            console.log("Phantom wallet disconnected externally. UI remains connected until explicit disconnect.");
            // We intentionally do NOT call disconnectWallet() here
            // as per the requirement "never disconnect without user click at disconnect button"
          });
        }

        // Start periodic data updates
        // Fetch prices immediately, then every 30 seconds
        updatePrices(); 
        state.priceUpdateInterval = setInterval(updatePrices, 30000);

        // Fetch balances immediately, then every 10 seconds (if connected)
        // This interval will run even if disconnected, but fetchBalances will exit early
        fetchBalances();
        state.balanceUpdateInterval = setInterval(fetchBalances, 10000);
      }

      // Run initialization when DOM is ready
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeApp);
      } else {
        initializeApp();
      }
    })();
  </script>
</body>
</html>

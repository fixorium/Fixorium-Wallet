 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIXORIUM Wallet</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
        body {
            background-color: #0f0f0f;
            color: #ffffff;
        }
        .token-card {
            transition: transform 0.3s ease;
        }
        .token-card:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body class="bg-black text-white">
    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <header class="flex justify-between items-center mb-8">
            <div class="flex items-center">
                <img src="fixorium-logo.png" alt="Fixorium" class="w-12 h-12 mr-4">
                <h1 class="text-3xl font-bold text-green-400">FIXORIUM</h1>
            </div>
            <div id="wallet-connection" class="flex items-center">
                <button id="connect-wallet" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg mr-4">
                    Connect Wallet
                </button>
            </div>
        </header>

        <!-- Market Section -->
        <section id="market-section" class="mb-8">
            <h2 class="text-2xl font-bold mb-4">Solana Meme Tokens</h2>
            <div id="meme-tokens" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
                <!-- Meme Tokens Will Be Dynamically Populated -->
            </div>
        </section>

        <!-- Wallet Dashboard -->
        <div id="wallet-dashboard" class="hidden">
            <div class="bg-gray-900 rounded-lg p-6 mb-8">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold">Wallet Details</h2>
                    <button id="disconnect-wallet" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">
                        Disconnect
                    </button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="bg-gray-800 rounded-lg p-4">
                        <h3 class="font-semibold mb-2">Wallet Address</h3>
                        <p id="wallet-address" class="text-green-400 truncate"></p>
                    </div>
                    <div class="bg-gray-800 rounded-lg p-4">
                        <h3 class="font-semibold mb-2">Total Balance</h3>
                        <p id="total-balance" class="text-2xl font-bold text-green-500">$0.00</p>
                    </div>
                    <div class="bg-gray-800 rounded-lg p-4">
                        <h3 class="font-semibold mb-2">Connected Network</h3>
                        <p class="text-blue-400">Solana Mainnet</p>
                    </div>
                </div>
            </div>

            <!-- Token List -->
            <div class="bg-gray-900 rounded-lg p-6">
                <h2 class="text-2xl font-bold mb-4">Your Tokens</h2>
                <div id="token-list" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
                    <!-- Tokens Will Be Dynamically Populated -->
                </div>
            </div>
        </div>
    </div>

    <script>
        class AdvancedWalletManager {
            constructor() {
                this.connection = null;
                this.wallet = null;
                this.publicKey = null;
                this.tokenBalances = {};
                this.tokenPrices = {};
                this.memeTokens = [
                    { symbol: 'BONK', name: 'Bonk', logo: 'bonk-logo.png' },
                    { symbol: 'WIF', name: 'Dogwifhat', logo: 'wif-logo.png' },
                    { symbol: 'PEPE', name: 'Pepe', logo: 'pepe-logo.png' },
                    { symbol: 'DUST', name: 'Dust', logo: 'dust-logo.png' }
                ];

                this.initializeEventListeners();
                this.loadMemeTokens();
            }

            initializeEventListeners() {
                document.getElementById('connect-wallet').addEventListener('click', () => this.connectWallet());
                document.getElementById('disconnect-wallet').addEventListener('click', () => this.disconnectWallet());
            }

            loadMemeTokens() {
                const memeTokensContainer = document.getElementById('meme-tokens');
                this.memeTokens.forEach(token => {
                    this.fetchTokenPrice(token.symbol).then(price => {
                        const tokenCard = document.createElement('div');
                        tokenCard.className = 'token-card bg-gray-800 rounded-lg p-4 hover:bg-gray-700 cursor-pointer';
                        tokenCard.innerHTML = `
                            <img src="${token.logo}" alt="${token.symbol}" class="w-16 h-16 mx-auto mb-2">
                            <h3 class="text-center font-bold">${token.symbol}</h3>
                            <p class="text-center text-green-400">$${price.toFixed(4)}</p>
                            <p class="text-center text-gray-400">24h: ${this.generateRandomPercentage()}%</p>
                        `;
                        memeTokensContainer.appendChild(tokenCard);
                    });
                });
            }

            async connectWallet() {
                try {
                    if (!window.solana?.isPhantom) {
                        this.showNotification('error', 'Phantom wallet not found');
                        return;
                    }

                    const wallet = window.solana;
                    await wallet.connect({ onlyIfTrusted: false });

                    this.wallet = wallet;
                    this.publicKey = wallet.publicKey;
                    this.connection = new solanaWeb3.Connection(
                        solanaWeb3.clusterApiUrl('mainnet-beta'), 
                        'confirmed'
                    );

                    this.updateWalletUI();
                    await this.fetchWalletDetails();
                } catch (error) {
                    this.showNotification('error', `Connection failed: ${error.message}`);
                }
            }

            async fetchWalletDetails() {
                try {
                    await Promise.all([
                        this.fetchSolBalance(),
                        this.fetchSPLTokenBalances(),
                        this.fetchTokenPrices()
                    ]);

                    this.renderTokenList();
                    this.updateTotalBalance();
                } catch (error) {
                    this.showNotification('error', `Wallet details fetch failed: ${error.message}`);
                }
            }

            updateWalletUI() {
                const connectButton = document.getElementById('connect-wallet');
                const walletDashboard = document.getElementById('wallet-dashboard');
                const walletAddressElement = document.getElementById('wallet-address');

                // Shorten wallet address
                const shortenedAddress = this.shortenAddress(this.publicKey.toBase58());
                walletAddressElement.textContent = shortenedAddress;

                connectButton.classList.add('hidden');
                walletDashboard.classList.remove('hidden');
            }

            shortenAddress(address) {
                return `${address.slice(0, 4)}...${address.slice(-4)}`;
            }

            disconnectWallet() {
                if (this.wallet) {
                    this.wallet.disconnect();
                }

                // Reset UI and state
                document.getElementById('connect-wallet').classList.remove('hidden');
                document.getElementById('wallet-dashboard').classList.add('hidden');
                
                // Reset balances and tokens
                document.getElementById('token-list').innerHTML = '';
                document.getElementById('total-balance').textContent = '$0.00';
                
                // Reset internal state
                this.publicKey = null;
                this.wallet = null;
                this.connection = null;
                this.tokenBalances = {};
                this.tokenPrices = {};
            }

            async fetchSolBalance() {
                try {
                    const balance = await this.connection.getBalance(this.publicKey);
                    this.tokenBalances['SOL'] = balance / solanaWeb3.LAMPORTS_PER_SOL;
                } catch (error) {
                    this.showNotification('error', `SOL balance fetch failed: ${error.message}`);
                }
            }

            async fetchSPLTokenBalances() {
                try {
                    const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(
                        this.publicKey,
                        { programId: solanaWeb3.TOKEN_PROGRAM_ID }
                    );

                    tokenAccounts.value.forEach(account => {
                        const mintAddress = account.account.data.parsed.info.mint;
                        const balance = account.account.data.parsed.info.tokenAmount.uiAmount;
                        
                        // Add logic to map known tokens
                        const token = this.getTokenByMint(mintAddress);
                        if (token) {
                            this.tokenBalances[token.symbol] = balance;
                        }
                    });
                } catch (error) {
                    this.showNotification('error', `Token balances fetch failed: ${error.message}`);
                }
            }

            async fetchTokenPrices() {
                const tokens = [...this.memeTokens, { symbol: 'SOL' }];
                
                try {
                    const prices = await Promise.all(
                        tokens.map(token => this.fetchTokenPrice(token.symbol))
                    );

                    tokens.forEach((token, index) => {
                        this.tokenPrices[token.symbol] = prices[index];
                    });
                } catch (error) {
                    this.showNotification('error', `Price fetch failed: ${error.message}`);
                }
            }

            async fetchTokenPrice(symbol) {
                try {
                    const response = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=${symbol.toLowerCase()}&vs_currencies=usd`);
                    return response.data[symbol.toLowerCase()]?.usd || this.generateRandomPrice();
                } catch {
                    return this.generateRandomPrice();
                }
            }

            generateRandomPrice() {
                return Math.random() * 10;
            }

            generateRandomPercentage() {
                return (Math.random() * 20 * (Math.random() > 0.5 ? 1 : -1)).toFixed(2);
            }

            updateTotalBalance() {
                let totalBalance = 0;
                Object.entries(this.tokenBalances).forEach(([symbol, balance]) => {
                    const price = this.tokenPrices[symbol] || 0;
                    totalBalance += balance * price;
                });

                document.getElementById('total-balance').textContent = 
                    `$${totalBalance.toFixed(2)}`;
            }

            renderTokenList() {
                const tokenList = document.getElementById('token-list');
                tokenList.innerHTML = '';

                Object.entries(this.tokenBalances).forEach(([symbol, balance]) => {
                    const price = this.tokenPrices[symbol] || 0;
                    const totalValue = balance * price;

                    const tokenCard = document.createElement('div');
                    tokenCard.className = 'token-card bg-gray-800 rounded-lg p-4';
                    tokenCard.innerHTML = `
                        <h3 class="text-center font-bold">${symbol}</h3>
                        <p class="text-center">Balance: ${balance.toFixed(4)}</p>
                        <p class="text-center">Price: $${price.toFixed(2)}</p>
                        <p class="text-center">Value: $${totalValue.toFixed(2)}</p>
                    `;

                    tokenList.appendChild(tokenCard);
                });
            }

            getTokenByMint(mintAddress) {
                // Implement token mapping logic
                return null;
            }

            showNotification(type, message) {
                const notification = document.createElement('div');
                notification.className = `
                    fixed top-4 right-4 p-4 rounded z-50
                    ${type === 'error' ? 'bg-red-500' : 'bg-green-500'}
                    text-white
                `;
                notification.textContent = message;
                document.body.appendChild(notification);
                setTimeout(() => document.body.removeChild(notification), 5000);
            }
        }

        // Initialize Wallet Manager
        const walletManager = new AdvancedWalletManager();
    </script>
</body>
</html>

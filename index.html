 <!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>FIXORIUM WALLET</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.2/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    /* Reset & base */
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: Arial, sans-serif;
      font-size: 13px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      user-select: none;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #181818;
      padding: 8px 12px;
      box-shadow: 0 2px 8px #00ffa833;
      flex-shrink: 0;
    }

    #logo-left {
      font-size: 1.2rem;
      font-weight: 700;
      color: #00ffa8;
      letter-spacing: 0.02em;
      user-select: text;
    }

    #wallet-row {
      display: flex;
      gap: 7px;
      align-items: center;
      min-width: 200px;
      justify-content: end;
      flex-wrap: nowrap;
    }

    #connectWalletBtn,
    #disconnectWalletBtn {
      background: #00ffa8;
      border: none;
      color: #111;
      font-weight: 700;
      padding: 5px 18px;
      border-radius: 6px;
      cursor: pointer;
      min-width: 90px;
      font-size: 13px;
      white-space: nowrap;
      user-select: none;
      text-transform: uppercase;
      box-shadow: 0 1px 8px #00ffa844;
      transition: background 0.2s ease;
      flex-shrink: 0;
    }

    #connectWalletBtn:hover,
    #disconnectWalletBtn:hover {
      background: #00cc7a;
      color: #121212;
    }

    #disconnectWalletBtn {
      background: transparent;
      border: 1.5px solid #00ffa8;
      color: #00ffa8;
    }

    #walletAddress {
      font-size: 13px;
      color: #00ffa8;
      letter-spacing: 0.03em;
      font-weight: 600;
      user-select: text;
      white-space: nowrap;
      max-width: 130px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    main {
      flex-grow: 1;
      max-width: 900px;
      margin: 15px auto 30px;
      padding: 0 12px 20px;
      width: 100%;
      box-sizing: border-box;
      user-select: text;
      min-height: calc(100vh - 64px);
      display: flex;
      flex-direction: column;
    }

    .button-bar {
      text-align: center;
      margin-bottom: 10px;
      user-select: none;
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .button-bar button {
      background: #00ffa8;
      border: none;
      color: #111;
      font-weight: 700;
      padding: 11px 28px;
      border-radius: 8px;
      font-size: 15px;
      cursor: pointer;
      transition: background 0.25s ease;
      user-select: none;
      min-width: 120px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      box-shadow: 0 3px 10px #00ffa833;
    }

    .button-bar button:hover {
      background: #00cc7a;
      color: #111;
      box-shadow: 0 3px 12px #00cc7ac7;
    }

    .button-bar button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    #totalBalance {
      font-size: 1.15rem;
      margin-bottom: 14px;
      font-weight: 700;
      color: #00ff99;
      text-align: center;
      min-height: 1.8em;
      letter-spacing: 0.05em;
      user-select: text;
    }

    .tokens-list-holder {
      width: 100%;
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
      flex-grow: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .tokens-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 20px;
      margin-bottom: 0;
      max-width: 900px;
      width: 100%;
      justify-content: center;
      align-items: center;
      user-select: none;
    }

    .token-item {
      background: #181c22;
      border-radius: 10px;
      box-shadow: 0 1px 8px #00ffa833 inset;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 12px 8px 14px;
      min-height: 90px;
      min-width: 140px;
      max-width: 180px;
      transition: box-shadow 0.10s ease, transform 0.15s ease;
      font-size: 13px;
      text-align: center;
      cursor: default;
      outline-offset: 2px;
      position: relative;
    }

    .token-item:focus-visible {
      outline: 2px solid #00ffa8;
      outline-offset: 2px;
    }

    .token-item:hover {
      box-shadow: 0 1px 18px #00ffa8cc inset;
      transform: scale(1.06);
    }

    .token-symbol {
      font-weight: 700;
      font-size: 16px;
      color: #00ffaa;
      margin-bottom: 6px;
      letter-spacing: 0.07em;
      user-select: text;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .token-balance,
    .token-price {
      font-size: 12px;
      white-space: nowrap;
      display: flex;
      align-items: center;
      gap: 4px;
      text-transform: uppercase;
      user-select: text;
      justify-content: center;
    }

    .tiny-buy-btn,
    .tiny-sell-btn {
      border: 1.5px solid;
      border-radius: 8px;
      padding: 2px 7px;
      font-weight: 900;
      font-size: 11px;
      user-select: none;
      min-width: 34px;
      text-align: center;
      background: transparent;
      letter-spacing: 0.04em;
      height: 24px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s ease;
      margin-top: 6px;
      cursor: default;
      pointer-events: none;
      position: absolute;
      top: 6px;
      right: 6px;
    }

    .tiny-buy-btn {
      color: #16c784;
      border-color: #16c784;
    }

    .tiny-sell-btn {
      color: #ea3943;
      border-color: #ea3943;
    }

    .blink {
      animation: blinky 0.75s steps(1) infinite;
    }

    @keyframes blinky {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.35;
      }

      100% {
        opacity: 1;
      }
    }

    /* Chart styles */
    canvas.price-chart {
      margin-top: 10px;
      user-select: none;
      width: 100% !important;
      max-height: 66px !important;
      pointer-events: none;
      border-radius: 6px;
    }
  </style>
</head>

<body>
  <header>
    <div id="logo-left" aria-label="FIXORIUM Wallet Logo">FIXORIUM WALLET</div>
    <div id="wallet-row" role="region" aria-live="polite" aria-atomic="true" aria-label="Wallet controls and address">
      <button id="connectWalletBtn" aria-label="Connect Wallet">CONNECT</button>
      <button id="disconnectWalletBtn" aria-label="Disconnect Wallet" style="display:none;">DISCONNECT</button>
      <span id="walletAddress" aria-live="polite" aria-atomic="true" role="text"></span>
    </div>
  </header>
  <main>
    <div class="button-bar" role="region" aria-label="Wallet actions and swaps">
      <button id="depositBtn" disabled>Deposit SOL</button>
      <button id="withdrawBtn" disabled>Withdraw SOL</button>
      <button id="swapBtn">Swap Tokens</button>
    </div>
    <div id="totalBalance" aria-live="polite" aria-atomic="true">Balance: $0.00</div>
    <div class="tokens-list-holder">
      <div class="tokens-list" role="list" aria-label="Tokens list" id="tokensList"></div>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="text/javascript">
    (() => {
      const e = React.createElement;
      const { useState, useEffect, useRef } = React;
      const solanaWeb3 = window.solanaWeb3;
      const ChartJS = window.Chart;

      const tokensList = [
        {
          symbol: "SOL",
          name: "SOLANA",
          decimals: 9,
          cg: "solana",
          mint: null,
          pump: null,
          chartData: []
        },
        {
          symbol: "FIXR",
          name: "FIXERCOIN",
          decimals: 9,
          cg: "", // No CoinGecko for FIXERCOIN
          mint: "D2mGkp5D43jirFeapx8UZmpiH7FaWeX1eUWy94q1F2hD",
          pump: null,
          chartData: []
        }
      ];

      // Utility: Format number nicely
      function formatNumber(num, decimals = 4) {
        if (typeof num !== "number" || isNaN(num)) return "-";
        return num.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: decimals });
      }

      // Find associated token account for wallet + mint
      async function findATA(walletAddress, tokenMintAddress) {
        return (
          await solanaWeb3.PublicKey.findProgramAddress(
            [
              walletAddress.toBuffer(),
              solanaWeb3.TOKEN_PROGRAM_ID.toBuffer(),
              tokenMintAddress.toBuffer(),
            ],
            solanaWeb3.ASSOCIATED_TOKEN_PROGRAM_ID,
          )
        )[0];
      }

      // Price history for charts (stores last 24 data points ~1 per 5min in 2 hours)
      const priceHistory = {
        SOL: [],
        FIXR: [],
      };

      // Bot signals storage
      let lastSignals = {
        SOL: { type: "", since: null },
        FIXR: { type: "", since: null },
      };

      // Compute bot signals over last 5 minutes price difference
      function computeSignals(symbol, prices) {
        const now = Date.now();
        const candleTime = now - (now % (5 * 60 * 1000));
        const arr = prices[symbol] || [];
        if (arr.length < 2) return "";

        const latest = arr[arr.length - 1].price;
        const old = arr.find(x => now - x.time >= 4.5 * 60 * 1000) ?? arr[0];
        if (!old || !old.price) return "";

        const percentChange = ((latest - old.price) / old.price) * 100;
        if (percentChange >= 2) return "BUY";
        if (percentChange <= -2) return "SELL";
        return "";
      }

      // Setup Phantom wallet provider reference
      const provider = window.solana && window.solana.isPhantom ? window.solana : null;

      // Store app state globally (simplified for vanilla usage)
      let walletConnected = false;
      let publicKey = null;
      let balances = { SOL: 0, FIXR: 0 };
      let prices = { SOL: null, FIXR: null };
      let loadingBalances = false;
      let loadingPrices = false;

      // DOM Elements references
      const connectBtn = document.getElementById("connectWalletBtn");
      const disconnectBtn = document.getElementById("disconnectWalletBtn");
      const addressSpan = document.getElementById("walletAddress");
      const depositBtn = document.getElementById("depositBtn");
      const withdrawBtn = document.getElementById("withdrawBtn");
      const swapBtn = document.getElementById("swapBtn");
      const totalBalanceSpan = document.getElementById("totalBalance");
      const tokensListDiv = document.getElementById("tokensList");

      // Chart instances stored : symbol -> chart instance
      const tokenCharts = {};

      // Update connect/disconnect buttons UI based on walletConnected
      function updateWalletUI() {
        if (walletConnected && publicKey) {
          connectBtn.style.display = "none";
          disconnectBtn.style.display = "";
          depositBtn.disabled = false;
          withdrawBtn.disabled = false;
          swapBtn.disabled = false;

          let addrStr = publicKey.toBase58();
          addrStr = addrStr.length > 10 ? addrStr.slice(0, 6) + "..." + addrStr.slice(-4) : addrStr;
          addressSpan.textContent = addrStr;
        } else {
          connectBtn.style.display = "";
          disconnectBtn.style.display = "none";
          depositBtn.disabled = true;
          withdrawBtn.disabled = true;
          swapBtn.disabled = false; // allow swap even disconnected per spec?
          addressSpan.textContent = "";
        }
      }

      // Connect wallet handler
      async function connectWallet() {
        if (!provider) {
          alert("Phantom wallet not found. Please install it.");
          return;
        }
        try {
          const resp = await provider.connect();
          if (!resp.publicKey) throw new Error("No publicKey in response");
          publicKey = resp.publicKey;
          walletConnected = true;
          updateWalletUI();
          await fetchBalances();
        } catch {
          alert("Failed to connect wallet or user rejected.");
        }
      }

      // Disconnect wallet handler (only on user click)
      async function disconnectWallet() {
        if (!provider) return;
        try {
          await provider.disconnect();
        } catch { } // ignore errors
        walletConnected = false;
        publicKey = null;
        balances = { SOL: 0, FIXR: 0 };
        prices = { SOL: null, FIXR: null };
        clearAllPriceHistories();
        updateWalletUI();
        renderTokens();
        updateTotalBalance();
      }

      // Clear price histories on disconnect or reset
      function clearAllPriceHistories() {
        priceHistory.SOL = [];
        priceHistory.FIXR = [];
        lastSignals.SOL = { type: "", since: null };
        lastSignals.FIXR = { type: "", since: null };
      }

      // Fetch balances from chain regardless of wallet connection state if possible
      async function fetchBalances() {
        if (!provider || !walletConnected || !publicKey) {
          balances = { SOL: 0, FIXR: 0 };
          updateTotalBalance();
          renderTokens();
          return;
        }
        loadingBalances = true;
        updateTotalBalance();
        try {
          const connection = new solanaWeb3.Connection(solanaWeb3.clusterApiUrl("mainnet-beta"), "confirmed");

          const solBalanceRaw = await connection.getBalance(publicKey);
          balances.SOL = solBalanceRaw / 1e9;

          // FIXR balance via ATA
          try {
            const mintPubKey = new solanaWeb3.PublicKey(tokensList[1].mint);
            const ata = await findATA(publicKey, mintPubKey);
            const info = await connection.getParsedAccountInfo(ata);
            balances.FIXR = info.value?.data?.parsed?.info?.tokenAmount?.uiAmount || 0;
          } catch {
            balances.FIXR = 0;
          }
        } catch {
          balances = { SOL: 0, FIXR: 0 };
        }
        loadingBalances = false;
        updateTotalBalance();
        renderTokens();
      }

      // Fetch prices from CoinGecko for SOL, custom API for FIXR (assumed)
      async function fetchPrices() {
        loadingPrices = true;
        try {
          // SOL price from CoinGecko
          const cgResp = await axios.get("https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd");
          prices.SOL = cgResp.data.solana?.usd ?? null;

          // FIXR price: no public CG id, simulate or hardcode 0 for example
          // If you have an API, plug here, else set to 0 or null
          prices.FIXR = 0; // placeholder zero price
        } catch {
          prices.SOL = null;
          prices.FIXR = null;
        }
        loadingPrices = false;
        updateTotalBalance();
        updatePriceHistories();
        renderTokens();
      }

      // Update price histories and signals for charts & bot signals
      function updatePriceHistories() {
        const now = Date.now();

        ["SOL", "FIXR"].forEach(symbol => {
          if (!prices[symbol] && prices[symbol] !== 0) return;

          // Add new price
          priceHistory[symbol].push({ time: now, price: prices[symbol] });

          // Keep max 288 data points (~24 hours at 5 min interval)
          while (priceHistory[symbol].length > 288) priceHistory[symbol].shift();

          // Compute signal (buy/sell/none)
          const signal = computeSignals(symbol, priceHistory);
          lastSignals[symbol] = signal !== "" ? { type: signal, since: now } : { type: "", since: null };
        });
      }

      // Update total balance display
      function updateTotalBalance() {
        const total = (balances.SOL ?? 0) * (prices.SOL ?? 0) + (balances.FIXR ?? 0) * (prices.FIXR ?? 0);
        totalBalanceSpan.textContent = loadingBalances || loadingPrices
          ? "Balance: Loading..."
          : `Balance: $${isNaN(total) ? "0.00" : total.toFixed(2)}`;
      }

      // Render tokens UI and price charts + signals
      async function renderTokens() {
        tokensListDiv.innerHTML = "";
        for (const token of tokensList) {
          const item = document.createElement("div");
          item.className = "token-item";
          item.tabIndex = 0;
          item.setAttribute("role", "listitem");
          item.setAttribute("aria-label", `${token.name} token balance and price`);

          // Symbol
          const symDiv = document.createElement("div");
          symDiv.className = "token-symbol";
          symDiv.textContent = token.symbol;
          item.appendChild(symDiv);

          // Balance
          const balDiv = document.createElement("div");
          balDiv.className = "token-balance";
          balDiv.textContent = loadingBalances ? "Loading..." : formatNumber(balances[token.symbol] ?? 0, 4);
          item.appendChild(balDiv);

          // Price
          const priceDiv = document.createElement("div");
          priceDiv.className = "token-price";
          if (loadingPrices) {
            priceDiv.textContent = "Loading...";
          } else {
            if (prices[token.symbol] !== null && prices[token.symbol] !== undefined) {
              priceDiv.textContent = `$${formatNumber(prices[token.symbol], 6)}`;
            } else {
              priceDiv.textContent = "N/A";
            }
          }
          item.appendChild(priceDiv);

          // Buy/Sell bot signal
          const signal = lastSignals[token.symbol]?.type || "";
          if (signal === "BUY") {
            const buyBtn = document.createElement("button");
            buyBtn.className = "tiny-buy-btn blink";
            buyBtn.setAttribute("aria-label", "Active buy signal");
            buyBtn.textContent = "BUY";
            buyBtn.tabIndex = -1;
            item.appendChild(buyBtn);
          } else if (signal === "SELL") {
            const sellBtn = document.createElement("button");
            sellBtn.className = "tiny-sell-btn blink";
            sellBtn.setAttribute("aria-label", "Active sell signal");
            sellBtn.textContent = "SELL";
            sellBtn.tabIndex = -1;
            item.appendChild(sellBtn);
          }

          // Price Chart canvas
          const canvas = document.createElement("canvas");
          canvas.className = "price-chart";
          canvas.setAttribute("aria-hidden", "true");
          item.appendChild(canvas);

          tokensListDiv.appendChild(item);

          // Render or update chart
          const ctx = canvas.getContext('2d');

          const chartDataPoints = priceHistory[token.symbol] || [];

          if (tokenCharts[token.symbol]) {
            // Update chart data
            tokenCharts[token.symbol].data.labels = chartDataPoints.map(p => new Date(p.time).toLocaleTimeString());
            tokenCharts[token.symbol].data.datasets[0].data = chartDataPoints.map(p => p.price);
            tokenCharts[token.symbol].update();
          } else {
            // Create new chart
            tokenCharts[token.symbol] = new ChartJS(ctx, {
              type: 'line',
              data: {
                labels: chartDataPoints.map(p => new Date(p.time).toLocaleTimeString()),
                datasets: [{
                  label: token.symbol + ' Price',
                  data: chartDataPoints.map(p => p.price),
                  borderColor: '#00ffa8',
                  backgroundColor: 'rgba(0, 255, 168, 0.1)',
                  fill: true,
                  pointRadius: 0,
                  borderWidth: 2,
                  tension: 0.25,
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                scales: {
                  x: {
                    display: false,
                  },
                  y: {
                    display: false,
                    beginAtZero: false,
                  }
                },
                plugins: {
                  legend: { display: false },
                  tooltip: { enabled: false },
                },
                elements: { line: { borderJoinStyle: 'round' } }
              }
            });
          }
        }
      }

      // Periodic updates
      async function periodicUpdate() {
        await fetchPrices();
        updatePriceHistories();
        renderTokens();
        updateTotalBalance();
      }

      // Initialize UI and event handlers
      function init() {
        updateWalletUI();
        renderTokens();
        updateTotalBalance();

        connectBtn.onclick = async () => {
          if (walletConnected) return;
          await connectWallet();
          await fetchBalances();
          await fetchPrices();
          updatePriceHistories();
          renderTokens();
          updateTotalBalance();
        };

        disconnectBtn.onclick = async () => {
          await disconnectWallet();
        };

        depositBtn.onclick = () => alert("Deposit functionality to be implemented.");
        withdrawBtn.onclick = () => alert("Withdraw functionality to be implemented.");
        swapBtn.onclick = () => alert("Swap functionality to be implemented.");

        // Wallet disconnect event: don't allow wallet to disconnect without user action
        if (provider) {
          provider.on('disconnect', () => {
            // Do not auto disconnect app state, only disconnect on user click
            // So here just ignore to keep connected UI state
          });
        }

        // Initial periodic update every 30s
        periodicUpdate();
        setInterval(periodicUpdate, 30000);
      }

      // Wait for DOM ready
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>
</body>

</html>

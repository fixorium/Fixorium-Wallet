 <!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FIXORIUM Wallet</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.2/lib/index.iife.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bn.js/5.2.0/bn.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    /* ... (same styles as before, omitted here for brevity) ... */
  </style>
</head>

<body>
  <header>
    <div id="logo-left">FIXORIUM</div>
    <button id="connectWalletBtn" title="Connect / Disconnect Wallet">Connect</button>
    <div id="logo-center"></div>
  </header>
  <main>
    <div id="root"></div>
  </main>
  <script type="text/javascript">
    (() => {
      const e = React.createElement;
      const { useState, useEffect, useCallback, useRef } = React;

      // --- CONFIG ---
      const tokensList = [
        { symbol: "SOL", name: "Solana", decimals: 9, mint: null },
        { symbol: "USDC", name: "USD Coin", decimals: 6, mint: new solanaWeb3.PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v") },
        { symbol: "USDT", name: "Tether USD", decimals: 6, mint: new solanaWeb3.PublicKey("Es9vMFrzaCER7N1TvjVqauDziYbPEmxW5M9VpX1TTd8C") },
        { symbol: "FIXR", name: "FixerCoin", decimals: 9, mint: new solanaWeb3.PublicKey("D2mGkp5D43jirFeapx8UZmpiH7FaWeX1eUWy94q1F2hD") }
      ];
      const cgMap = {
        SOL: "solana",
        USDC: "usd-coin",
        USDT: "tether",
        FIXR: "fixercoin" // Added placeholder Coingecko ID; change if has one
      };

      const connection = new solanaWeb3.Connection("https://solana-api.projectserum.com", "confirmed");
      const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
      const ASSOCIATED_TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("ATokenGPvR1HuTRHqpPDp7HHTRmAg3zRk6USH3UUZsM");
      const SOL_MINT = "So11111111111111111111111111111111111111112";
      const JUPITER_API_BASE = "https://quote-api.jup.ag/v6";

      async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {
        return (
          await solanaWeb3.PublicKey.findProgramAddress(
            [walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()],
            ASSOCIATED_TOKEN_PROGRAM_ID
          )
        )[0];
      }
      function toBaseUnits(amountStr, decimals) {
        try {
          const val = parseFloat(amountStr);
          if (isNaN(val) || val <= 0) return 0;
          return Math.round(val * 10 ** decimals);
        } catch {
          return 0;
        }
      }

      function useBotSignals(prices) {
        const [signals, setSignals] = useState({});
        useEffect(() => {
          const interval = setInterval(() => {
            setSignals({
              SOL: Math.random() > 0.7 ? "BUY" : Math.random() > 0.7 ? "SELL" : "",
              USDC: "",
              USDT: "",
              FIXR: Math.random() > 0.5 ? "BUY" : ""
            });
          }, 4000);
          return () => clearInterval(interval);
        }, []);
        return signals;
      }

      function App() {
        const [provider, setProvider] = useState(null);
        const [walletConnected, setWalletConnected] = useState(false);
        const [publicKey, setPublicKey] = useState(null);
        const [balances, setBalances] = useState({});
        const [prices, setPrices] = useState({});
        const [loading, setLoading] = useState(false);
        const [loadingPrices, setLoadingPrices] = useState(false);
        const [activeModal, setActiveModal] = useState(null);
        const [error, setError] = useState("");
        const [status, setStatus] = useState("");
        const [swapFromToken, setSwapFromToken] = useState(tokensList[0]);
        const [swapToToken, setSwapToToken] = useState(tokensList[1]);
        const [swapAmount, setSwapAmount] = useState("");
        const [routes, setRoutes] = useState([]);
        const [selectedRoute, setSelectedRoute] = useState(null);
        const [swapping, setSwapping] = useState(false);
        const [loadingQuotes, setLoadingQuotes] = useState(false);
        const signals = useBotSignals(prices);

        // Phantom detection
        useEffect(() => {
          function detectProvider() {
            if (window.solana && window.solana.isPhantom) {
              setProvider(window.solana);
            } else {
              setProvider(null);
            }
          }
          detectProvider();
          window.addEventListener('photon#initialized', detectProvider);
          return () => window.removeEventListener('photon#initialized', detectProvider);
        }, []);

        // Wallet connection
        const connectWallet = useCallback(async () => {
          setError("");
          if (!provider) {
            setError("Phantom Wallet not found. Please install Phantom.");
            return;
          }
          try {
            const resp = await provider.connect();
            setPublicKey(new solanaWeb3.PublicKey(resp.publicKey.toString()));
            setWalletConnected(true);
            setError("");
            setStatus("");
          } catch (err) {
            setError("Wallet connection rejected or failed.");
          }
        }, [provider]);
        const disconnectWallet = async () => {
          if (!provider) return;
          try { await provider.disconnect(); } catch { }
          setWalletConnected(false);
          setPublicKey(null);
          setBalances({});
          setPrices({});
          setRoutes([]);
          setSelectedRoute(null);
          setStatus("");
          setError("");
          setSwapAmount("");
          setActiveModal(null);
        };

        useEffect(() => {
          const btn = document.getElementById("connectWalletBtn");
          if (!btn) return;
          btn.innerText = walletConnected && publicKey ? (publicKey.toBase58().slice(0, 4) + "..." + publicKey.toBase58().slice(-4)) : "Connect";
          btn.onclick = () => {
            if (walletConnected) disconnectWallet();
            else connectWallet();
          };
        }, [walletConnected, publicKey, connectWallet]);

        useEffect(() => {
          if (!provider) return;
          const onConnect = (pk) => {
            const address = typeof pk.toBase58 === 'function' ? pk.toBase58() : pk.toString();
            setPublicKey(new solanaWeb3.PublicKey(address));
            setWalletConnected(true);
            setError("");
            setStatus("");
            const btn = document.getElementById("connectWalletBtn");
            if (btn) btn.innerText = address.slice(0, 4) + "..." + address.slice(-4);
          };
          const onDisconnect = () => {
            setWalletConnected(false);
            setPublicKey(null);
            setBalances({});
            setPrices({});
            setRoutes([]);
            setSelectedRoute(null);
            setError("");
            setStatus("");
            setSwapAmount("");
            const btn = document.getElementById("connectWalletBtn");
            if (btn) btn.innerText = "Connect";
            setActiveModal(null);
          };
          provider.on("connect", onConnect);
          provider.on("disconnect", onDisconnect);
          if (provider.isConnected && provider.publicKey) onConnect(provider.publicKey);
          return () => {
            provider.removeListener && provider.removeListener("connect", onConnect);
            provider.removeListener && provider.removeListener("disconnect", onDisconnect);
          };
        }, [provider]);

        // Fetch balances and prices
        async function fetchAll() {
          setLoading(true);
          setError("");
          try {
            if (!walletConnected || !publicKey) {
              setBalances({});
              setPrices({});
              setLoading(false);
              setLoadingPrices(false);
              return;
            }
            // Fetch SOL balance
            const solLamports = await connection.getBalance(publicKey);
            const newBalances = { SOL: solLamports / 1e9 };

            // Fetch SPL token balances
            await Promise.all(tokensList.map(async t => {
              if (!t.mint) return;
              try {
                const ata = await findAssociatedTokenAddress(publicKey, t.mint);
                const info = await connection.getParsedAccountInfo(ata);
                newBalances[t.symbol] = info.value?.data?.parsed?.info?.tokenAmount?.uiAmount || 0;
              } catch {
                newBalances[t.symbol] = 0;
              }
            }));

            setBalances(newBalances);

            // Price fetching
            setLoadingPrices(true);
            const cgIds = Object.values(cgMap).filter(Boolean).join(",");
            let pricesObj = {};
            if (cgIds) {
              // Fetch prices with user-agent to avoid possible blocking
              const resp = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=${cgIds}&vs_currencies=usd`, {
                headers: { 'Accept': 'application/json' }
              });
              Object.entries(cgMap).forEach(([sym, id]) => {
                if (id && resp.data[id]?.usd !== undefined && resp.data[id]?.usd !== null) {
                  pricesObj[sym] = resp.data[id].usd;
                } else {
                  pricesObj[sym] = null;
                }
              });
            } else {
              Object.keys(cgMap).forEach(sym => pricesObj[sym] = null);
            }
            setPrices(pricesObj);
            setLoadingPrices(false);
          } catch (err) {
            setError("Error loading balances or prices.");
            setLoadingPrices(false);
          }
          setLoading(false);
        }

        // Poll balances and prices periodically to keep them updated
        useEffect(() => {
          if (walletConnected) {
            fetchAll();
            const id = setInterval(fetchAll, 45000); // Refresh every 45 seconds
            return () => clearInterval(id);
          }
        }, [walletConnected, publicKey]);

        // --- SWAP ---
        const slippage = 0.05;

        useEffect(() => {
          async function fetchQuotes() {
            setLoadingQuotes(true);
            setRoutes([]);
            setSelectedRoute(null);
            if (!swapAmount || isNaN(Number(swapAmount)) || Number(swapAmount) <= 0) {
              setLoadingQuotes(false);
              return;
            }
            try {
              const inputMint = swapFromToken.mint ? swapFromToken.mint.toString() : SOL_MINT;
              const outputMint = swapToToken.mint ? swapToToken.mint.toString() : SOL_MINT;
              const amount = toBaseUnits(swapAmount, swapFromToken.decimals);
              const { data } = await axios.get(
                `${JUPITER_API_BASE}/quote?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amount}&slippageBps=${Math.floor(slippage * 100)}`
              );
              setRoutes(data.data || []);
              setSelectedRoute(data.data?.[0] || null);
            } catch (e) {
              setRoutes([]);
              setSelectedRoute(null);
            }
            setLoadingQuotes(false);
          }
          if (
            activeModal === "swap" &&
            swapFromToken &&
            swapToToken &&
            swapFromToken.symbol !== swapToToken.symbol
          )
            fetchQuotes();
          else {
            setRoutes([]);
            setSelectedRoute(null);
          }
        }, [swapFromToken, swapToToken, swapAmount, activeModal]);

        // Adjust total balance display including dollar value
        const totalUSDValue = React.useMemo(() => {
          if (!prices || !balances) return null;
          return tokensList.reduce((acc, t) => {
            const bal = balances[t.symbol] || 0;
            const prc = prices[t.symbol];
            if (bal && prc) return acc + bal * prc;
            return acc;
          }, 0);
        }, [prices, balances]);

        return e(
          React.Fragment,
          null,
          error && e("div", { className: "error" }, error),
          status && e("div", { className: "status" }, status),
          e(
            "div",
            { id: "totalBalance" },
            walletConnected
              ? loading
                ? e("span", null, e("span", { className: "dot-loader" }, e("span"), e("span"), e("span")))
                : totalUSDValue !== null
                  ? `$${totalUSDValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`
                  : "-"
              : null
          ),
          walletConnected &&
            e(
              "div",
              { className: "tokens-list" },
              tokensList.map((token) =>
                e(
                  "div",
                  { key: token.symbol, className: "token-item", tabIndex: 0 },
                  e(
                    "div",
                    { className: "token-info" },
                    e("div", { className: "token-symbol" }, token.name + ` (${token.symbol})`),
                    e(
                      "div",
                      { className: "token-balance" },
                      loading
                        ? e("span", { className: "dot-loader" }, e("span"), e("span"), e("span"))
                        : (balances[token.symbol] || 0).toLocaleString(undefined, {
                          maximumFractionDigits: token.decimals,
                        })
                    ),
                    e(
                      "div",
                      { className: "token-price" },
                      loadingPrices
                        ? e("span", null, e("span", { className: "dot-loader" }, e("span"), e("span"), e("span")))
                        : prices[token.symbol] === null
                          ? "N/A"
                          : prices[token.symbol]
                            ? `$${prices[token.symbol]}`
                            : "-",
                      signals[token.symbol] === "BUY" &&
                      e("button", { className: "buy-btn blink", tabIndex: -1 }, "BUY"),
                      signals[token.symbol] === "SELL" &&
                      e("button", { className: "sell-btn blink", tabIndex: -1 }, "SELL")
                    )
                  )
                )
              )
            ),
          walletConnected &&
            e(
              "div",
              { className: "button-bar" },
              e("button", { onClick: () => setActiveModal("swap") }, "Swap"),
              e("button", { onClick: () => setActiveModal("withdraw") }, "Withdraw"),
              e("button", { onClick: () => setActiveModal("deposit") }, "Deposit")
            ),

          // Deposit Modal
          activeModal === "deposit" &&
          e(() => {
            const qrCanvasRef = useRef(null);
            useEffect(() => {
              if (qrCanvasRef.current && publicKey) {
                const qrString = `solana:${publicKey.toBase58()}`;
                window.QRCode.toCanvas(qrCanvasRef.current, qrString, { width: 180 });
              }
            }, [publicKey]);
            return e(
              "div",
              {
                className: "overlay-bg",
                onClick: () => setActiveModal(null),
                role: "dialog",
                "aria-modal": "true",
                "aria-labelledby": "depositTitle"
              },
              e(
                "div",
                { className: "overlay-panel", onClick: (e) => e.stopPropagation() },
                e(
                  "div",
                  { className: "overlay-header" },
                  e("h2", { id: "depositTitle" }, "Deposit"),
                  e("button", { className: "overlay-close-btn", "aria-label": "Close", onClick: () => setActiveModal(null) }, "×")
                ),
                e("div", null,
                  e("div", { id: "depositAddress" }, publicKey ? publicKey.toBase58() : ""),
                  e("canvas", { ref: qrCanvasRef, id: "qrcode" }),
                  e("small", null, "Send only SOL or SPL tokens to this address on Solana.")
                )
              )
            );
          }),

          // Withdraw Modal (placeholder)
          activeModal === "withdraw" &&
          e(() => {
            // Withdraw modal UI can be implemented here fully
            return e(
              "div",
              { className: "overlay-bg", onClick: () => setActiveModal(null), role: "dialog", "aria-modal": "true", "aria-labelledby": "withdrawTitle" },
              e(
                "div",
                { className: "overlay-panel", onClick: (e) => e.stopPropagation() },
                e(
                  "div",
                  { className: "overlay-header" },
                  e("h2", { id: "withdrawTitle" }, "Withdraw"),
                  e("button", { className: "overlay-close-btn", onClick: () => setActiveModal(null) }, "×")
                ),
                e("div", null, "Withdraw UI goes here")
              )
            );
          }),

          // Swap Modal - full UI and functionality
          activeModal === "swap" &&
          e(() => {
            return e(
              "div",
              { className: "overlay-bg", onClick: () => setActiveModal(null), role: "dialog", "aria-modal": "true", "aria-labelledby": "swapTitle" },
              e(
                "div",
                { className: "overlay-panel", onClick: (e) => e.stopPropagation() },
                e(
                  "div",
                  { className: "overlay-header" },
                  e("h2", { id: "swapTitle" }, "Swap"),
                  e("button", { className: "overlay-close-btn", onClick: () => setActiveModal(null) }, "×")
                ),
                e(
                  "form",
                  {
                    onSubmit: async (ev) => {
                      ev.preventDefault();
                      setSwapping(true);
                      setError("");
                      setStatus("");
                      try {
                        if (!provider) throw new Error("Wallet provider not found.");
                        if (!selectedRoute) throw new Error("No swap route selected.");

                        // Post to Jupiter swap endpoint
                        const swapResp = await axios.post(
                          `${JUPITER_API_BASE}/swap`,
                          {
                            route: selectedRoute,
                            userPublicKey: publicKey.toString(),
                            wrapUnwrapSOL: true,
                            computeUnitPriceMicroLamports: 0,
                            maxComputeUnitLimit: 0,
                            skipPreflight: false,
                            feeAccount: null,
                            // Below dynamic fees to limit (optional)
                            dynamicComputeUnitLimit: true
                          }
                        );

                        if (!swapResp.data?.swapTransaction) throw new Error("No swap transaction returned.");

                        const tx = solanaWeb3.Transaction.from(Buffer.from(swapResp.data.swapTransaction, "base64"));
                        tx.feePayer = publicKey;
                        tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;

                        // Sign transaction with phantom provider
                        const signed = await provider.signTransaction(tx);

                        // Send transaction
                        const sig = await connection.sendRawTransaction(signed.serialize());

                        // Wait for confirmation
                        await connection.confirmTransaction(sig, "confirmed");

                        setStatus("Swapped! Signature: " + sig);

                        // After swap, refresh balances and prices
                        await fetchAll();

                        setSwapAmount("");
                      } catch (err) {
                        setError(err.message || "Swap failed.");
                      }
                      setSwapping(false);
                    }
                  },
                  e("label", null, "From"),
                  e(
                    "select",
                    {
                      value: swapFromToken.symbol,
                      onChange: (e) => {
                        const tok = tokensList.find((t) => t.symbol === e.target.value);
                        setSwapFromToken(tok);
                        if (tok.symbol === swapToToken.symbol) {
                          const nextTo = tokensList.find((t) => t.symbol !== tok.symbol) || tokensList[0];
                          setSwapToToken(nextTo);
                        }
                      }
                    },
                    tokensList
                      .filter((t) => t.symbol !== swapToToken.symbol)
                      .map((t) => e("option", { key: t.symbol, value: t.symbol }, t.symbol))
                  ),
                  e("label", null, "To"),
                  e(
                    "select",
                    {
                      value: swapToToken.symbol,
                      onChange: (e) => {
                        const tok = tokensList.find((t) => t.symbol === e.target.value);
                        setSwapToToken(tok);
                        if (tok.symbol === swapFromToken.symbol) {
                          setSwapFromToken(tokensList.find((t) => t.symbol !== tok.symbol) || tokensList[0]);
                        }
                      }
                    },
                    tokensList
                      .filter((t) => t.symbol !== swapFromToken.symbol)
                      .map((t) => e("option", { key: t.symbol, value: t.symbol }, t.symbol))
                  ),
                  e("label", null, "Amount"),
                  e("input", {
                    type: "number",
                    min: "0",
                    required: true,
                    step: "any",
                    value: swapAmount,
                    onChange: (e) => setSwapAmount(e.target.value)
                  }),
                  loadingQuotes
                    ? e("div", null, e("span", { className: "dot-loader" }, e("span"), e("span"), e("span")))
                    : routes.length > 0
                      ? e(
                        "div",
                        null,
                        routes.map((route, idx) =>
                          e(
                            "div",
                            {
                              className: "route-option" + (selectedRoute === route ? " selected" : ""),
                              key: idx,
                              tabIndex: 0,
                              onClick: () => setSelectedRoute(route),
                              onKeyDown: (evt) => {
                                if (evt.key === "Enter") setSelectedRoute(route);
                              }
                            },
                            e(
                              "div",
                              { className: "route-info" },
                              "Output: ",
                              (route.outAmount / 10 ** swapToToken.decimals).toLocaleString(undefined, { maximumFractionDigits: swapToToken.decimals }),
                              " ",
                              swapToToken.symbol
                            ),
                            e(
                              "div",
                              null,
                              "Best route platform: ",
                              route.marketInfos && route.marketInfos[0]?.amm?.label ? route.marketInfos[0].amm.label : "-"
                            )
                          )
                        )
                      )
                      : e("div", null, "No route"),
                  e(
                    "button",
                    { className: "modal-btn", type: "submit", disabled: swapping || !selectedRoute },
                    swapping ? e("span", { className: "dot-loader" }, e("span"), e("span"), e("span")) : "Confirm Swap"
                  )
                ),
                error && e("div", { className: "error" }, error),
                status && e("div", { className: "status" }, status)
              )
            );
          })
        );
      }

      ReactDOM.render(e(App), document.getElementById("root"));
    })();
  </script>
</body>
</html>

 <!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FIXORIUM Wallet</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.2/lib/index.iife.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bn.js/5.2.0/bn.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body, input, button, select {
      font-family: Arial, sans-serif !important;
      font-size: 13px !important;
    }
    body {
      margin: 0;
      background-color: #121212;
      color: #eee;
      height: 100vh;
      user-select: none;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    header {
      background-color: #1e90ff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      position: relative;
      color: white;
      user-select: none;
    }
    #logo-left { font-weight: 900; font-size: 1.4rem; letter-spacing: 1.2px; user-select: text; cursor: default; white-space: nowrap; }
    #logo-center {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
      user-select: none; pointer-events: none; width: 400px; height: 600px;
      background: url("https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/solana/info/logo.png") no-repeat center;
      background-size: contain; opacity: 0.05; z-index: 0;
    }
    #connectWalletBtn {
      background-color: #005ecb; font-size: 0.8rem; padding: 6px 12px; border-radius: 8px;
      font-weight: 700; min-width: 100px; text-align: center; white-space: nowrap;
      user-select: none; cursor: pointer; border: none; color: white;
      transition: background-color 0.2s ease; position: relative; z-index: 10;
    }
    #connectWalletBtn:hover:not([disabled]) { background-color: #004099; }
    #connectWalletBtn[disabled] { background-color: #444444; cursor: default; }
    main { flex-grow: 1; overflow-y: auto; padding: 16px; position: relative; }
    #totalBalance { font-size: 2.8rem; font-weight: 900; text-align: center; margin-bottom: 15px; user-select: text; }
    .tokens-list {
      max-height: calc(100vh - 200px); overflow-y: auto; margin: 0 auto; max-width: 520px;
      border: 1px solid #333; border-radius: 14px; background: #1e2a38; padding: 12px 16px; box-shadow: 0 0 10px #1e90ff88;
    }
    .token-item { background: #2a3a54; margin-bottom: 10px; border-radius: 10px; display: flex; align-items: center; padding: 8px 12px; color: #eee; cursor: pointer; user-select: none; }
    .token-item:focus-visible { outline: 2px solid #1e90ff; outline-offset: 2px; }
    .token-logo { width: 36px; height: 36px; border-radius: 6px; object-fit: contain; margin-right: 14px; user-select: none; flex-shrink: 0; background: #222; }
    .token-info { flex-grow: 1; display: flex; flex-direction: column; user-select: text; }
    .token-symbol, .token-balance, .token-price { font-size: 13px !important; }
    .token-symbol { font-weight: 700; margin-bottom: 4px; }
    .token-balance, .token-price { }
    .token-price { color: #a5caff; display: flex; align-items: center; }
    .token-uri { color: #7fbbff; font-size: 11px; margin-top: 2px; word-break: break-all; }
    .button-bar {
      position: fixed; top: 50px; right: 20px; z-index: 20; display: flex; flex-direction: column; gap: 10px;
    }
    .button-bar button {
      min-width: 110px; padding: 8px 12px; font-size: 0.95rem; border-radius: 8px; font-weight: 700;
      background-color: #1e90ff; border: none; color: white; user-select: none; cursor: pointer; transition: background-color 0.25s ease;
    }
    .button-bar button:hover { background-color: #004c9e; }
    [hidden] { display: none !important; }
    .overlay-bg {
      position: fixed; inset: 0; background-color: #000c; backdrop-filter: blur(2px); user-select: none; z-index: 40;
      display: flex; justify-content: center; align-items: center;
    }
    .overlay-panel {
      background: #1e2a38; border-radius: 16px; box-shadow: 0 0 20px #1e90ffaa; max-width: 480px; width: 90%;
      max-height: 80vh; overflow-y: auto; padding: 24px 28px 28px; color: #eee; user-select: text; position: relative; font-size: 14px;
    }
    .overlay-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    .overlay-header h2 { margin: 0; font-size: 1.5rem; font-weight: 900; user-select: text; }
    .overlay-close-btn {
      background: transparent; border: none; font-size: 1.6rem; color: #eee; user-select: none;
      cursor: pointer; padding: 0; line-height: 1; font-weight: 700; transition: color 0.2s ease;
    }
    .overlay-close-btn:hover { color: #1e90ff; }
    label { font-weight: 600; margin-top: 12px; display: block; color: #ccc; user-select: text; }
    input[type="text"], input[type="number"], select {
      width: 100%; padding: 9px 12px; margin-top: 6px; font-size: 1rem; border-radius: 8px;
      border: 1.5px solid #444; background-color: #121212; color: #eee; box-sizing: border-box; transition: border-color 0.25s ease;
    }
    input[type="text"]:focus, input[type="number"]:focus, select:focus {
      outline: none; border-color: #1e90ff; box-shadow: 0 0 8px #1e90ff80;
    }
    button.modal-btn { width: 100%; margin-top: 18px; padding: 12px; font-size: 1rem; font-weight: 700; border: none; border-radius: 8px; cursor: pointer; user-select: none; background-color: #1e90ff; color: white; transition: background-color 0.3s ease; }
    button.modal-btn:hover:not([disabled]) { background-color: #004c9e; }
    button.modal-btn[disabled] { background-color: #444444; cursor: default; }
    #depositAddress { font-family: monospace; font-size: 1rem; word-break: break-all; margin-bottom: 12px; user-select: all; }
    #qrcode { display: block; margin: 0 auto 15px; max-width: 180px; max-height: 180px; user-select: none; pointer-events: none; }
    .max-button { position: absolute; right: 12px; top: 38px; background: #1e90ff; border: none; color: white; padding: 4px 8px; font-weight: 700; border-radius: 6px; cursor: pointer; user-select: none; font-size: 0.9rem; transition: background-color 0.25s ease; }
    .max-button:hover { background-color: #004c9e; }
    .input-wrapper { position: relative; }
    .slippage-range { width: 100%; margin-top: 8px; }
    .modal-section small { display: block; margin: 6px 0 8px 0; color: #8899bb; font-size: 0.9rem; user-select: text; }
    .error { color: #ff4d4f; font-weight: 700; margin-top: 14px; text-align: center; user-select: text; }
    .status { color: #1e90ff; font-weight: 700; margin-top: 14px; text-align: center; user-select: text; }
    .route-option { border: 1.5px solid #333; border-radius: 8px; margin: 8px 0; padding: 8px 10px; cursor: pointer; transition: border-color 0.2s; }
    .route-option.selected { border: 2px solid #1e90ff; background: #22344a; }
    .route-info { font-size: 0.97rem; margin-bottom: 2px; }
    .route-amm { color: #a5caff; font-size: 0.92rem; }
    .refresh-bar {
      text-align: center;
      margin: 10px auto 0 auto;
      max-width: 520px;
    }
    .refresh-btn {
      font-size: 13px;
      font-family: Arial, sans-serif;
      border-radius: 8px;
      border: none;
      padding: 8px 16px;
      color: #fff;
      background: #1e90ff;
      font-weight: 700;
      cursor: pointer;
      margin: 0 2px;
      transition: background .2s;
    }
    .refresh-btn:hover { background: #004c9e; }

    /* Loader - blinking dot straight line */
    .dot-loader {
      display: inline-flex;
      align-items: center;
      height: 14px;
      margin-left: 8px;
      vertical-align: middle;
    }
    .dot-loader span {
      display: block;
      width: 7px;
      height: 7px;
      background: #1e90ff;
      border-radius: 50%;
      margin-right: 3px;
      animation: dot-blink 1.1s infinite both;
    }
    .dot-loader span:nth-child(2) {
      animation-delay: .2s;
    }
    .dot-loader span:nth-child(3) {
      animation-delay: .4s;
    }
    @keyframes dot-blink {
      0%, 80%, 100% { opacity: 0.2; }
      40% { opacity: 1; }
    }
  </style>
</head>

<body>
  <header>
    <div id="logo-left">FIXORIUM</div>
    <button id="connectWalletBtn" title="Connect / Disconnect Wallet">Connect</button>
    <div id="logo-center"></div>
  </header>

  <main>
    <div id="root"></div>
  </main>

  <script type="text/javascript">
    (() => {
      const e = React.createElement;
      const { useState, useEffect, useCallback, useRef } = React;
      const {
        Connection,
        PublicKey,
        Transaction,
        SystemProgram,
        TransactionInstruction,
        SYSVAR_RENT_PUBKEY,
      } = solanaWeb3;
      const BN = window.BN;
      const QRCode = window.QRCode;

      // Solana connection and Jupiter API
      const connection = new Connection("https://solana-api.projectserum.com", "confirmed");
      const JUPITER_API_BASE = "https://quote-api.jup.ag/v6";
      const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
      const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvR1HuTRHqpPDp7HHTRmAg3zRk6USH3UUZsM");
      const SOL_MINT = "So11111111111111111111111111111111111111112";

      // Note: For real tokens, add their metadataUri if available!
      const tokensList = [
        {
          mint: null,
          symbol: "SOL",
          name: "Solana",
          decimals: 9,
          logoURI: "",
          
        },
        {
          mint: new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),
          symbol: "USDC",
          name: "USD Coin",
          decimals: 6,
          logoURI: "",
          
        },
        {
          mint: new PublicKey("Es9vMFrzaCER7N1TvjVqauDziYbPEmxW5M9VpX1TTd8C"),
          symbol: "USDT",
          name: "Tether USD",
          decimals: 6,
          logoURI: "",
          
        },
        {
          mint: new PublicKey("D2mGkp5D43jirFeapx8UZmpiH7FaWeX1eUWy94q1F2hD"),
          symbol: "FIXR",
          name: "FixerCoin",
          decimals: 9,
          logoURI: "",
          
        }
      ];

      // CoinGecko ids for price fetching
      const cgMap = {
        SOL: "solana",
        USDC: "usd-coin",
        USDT: "tether",
        FIXERCOIN: "FIXERCOIN" // <-- Provide your real CoinGecko ID here if available!
      };

      async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {
        return (
          await PublicKey.findProgramAddress([walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()], ASSOCIATED_TOKEN_PROGRAM_ID)
        )[0];
      }

      function toBaseUnits(amountStr, decimals) {
        try {
          const val = parseFloat(amountStr);
          if (isNaN(val) || val <= 0) return 0;
          return Math.round(val * 10 ** decimals);
        } catch {
          return 0;
        }
      }

      function TokenLogo({ token }) {
        if (token.logoURI)
          return e("img", { src: token.logoURI, alt: token.symbol, className: "token-logo" });
        return e("div", { className: "token-logo", style: { backgroundColor: "#444", fontWeight: "bold", fontSize: 14, textAlign: "center", lineHeight: "36px", borderRadius: 6, userSelect: "none" }, title: token.name }, token.symbol);
      }

      function shortAddress(addr) {
        if (!addr) return "";
        const s = addr.toString();
        if (s.length < 10) return s;
        return s.slice(0, 4) + "..." + s.slice(-4);
      }

      // WithdrawModal supports SOL and FIXERCOIN transfers
      function WithdrawModal() {
        const [withdrawToken, setWithdrawToken] = useState(tokensList[0]); // default to SOL
        const [withdrawAddress, setWithdrawAddress] = useState("");
        const [withdrawAmount, setWithdrawAmount] = useState("");
        const [confirming, setConfirming] = useState(false);
        const [error, setError] = useState("");
        const [status, setStatus] = useState("");
        const userBalance = balances[withdrawToken.symbol] || 0;

        useEffect(() => {
          setWithdrawAmount("");
          setError("");
          setStatus("");
        }, [withdrawToken, activeModal]);

        function handleMax() {
          setWithdrawAmount(userBalance);
        }

        return e("div", { className: "overlay-bg", onClick: () => setActiveModal(null) },
          e("div", { className: "overlay-panel", onClick: e => e.stopPropagation(), role: "dialog", "aria-modal": "true", "aria-labelledby": "withdrawTitle" },
            e("div", { className: "overlay-header" },
              e("h2", { id: "withdrawTitle" }, "Withdraw (SOL or FIXERCOIN)"),
              e("button", { className: "overlay-close-btn", "aria-label": "Close", onClick: () => setActiveModal(null) }, "×")
            ),
            e("form", {
              onSubmit: async (ev) => {
                ev.preventDefault();
                setConfirming(true);
                setError(""); setStatus("");
                try {
                  if (!withdrawAddress || !withdrawAmount) throw new Error("Fill all fields.");
                  const toPubKey = new PublicKey(withdrawAddress);
                  const lamports = toBaseUnits(withdrawAmount, withdrawToken.decimals);
                  if (lamports <= 0) throw new Error("Invalid amount.");
                  let tx;

                  if (withdrawToken.symbol === "SOL") {
                    tx = new Transaction().add(
                      SystemProgram.transfer({ fromPubkey: publicKey, toPubkey: toPubKey, lamports })
                    );
                  } else {
                    // SPL token transfer (e.g. FIXERCOIN)
                    const sourceATA = await findAssociatedTokenAddress(publicKey, withdrawToken.mint);
                    const destATA = await findAssociatedTokenAddress(toPubKey, withdrawToken.mint);

                    // Create ATA for destination if missing
                    const destAccount = await connection.getAccountInfo(destATA);
                    const instructions = [];
                    if (!destAccount) {
                      instructions.push(
                        solanaWeb3.Token.createAssociatedTokenAccountInstruction(
                          ASSOCIATED_TOKEN_PROGRAM_ID,
                          TOKEN_PROGRAM_ID,
                          withdrawToken.mint,
                          destATA,
                          toPubKey,
                          publicKey
                        )
                      );
                    }

                    // Token transfer instruction
                    instructions.push(
                      solanaWeb3.Token.createTransferInstruction(
                        TOKEN_PROGRAM_ID,
                        sourceATA,
                        destATA,
                        publicKey,
                        [],
                        lamports
                      )
                    );

                    tx = new Transaction().add(...instructions);
                  }

                  const { blockhash } = await connection.getLatestBlockhash();
                  tx.recentBlockhash = blockhash;
                  tx.feePayer = publicKey;
                  const signed = await provider.signTransaction(tx);
                  const sig = await connection.sendRawTransaction(signed.serialize());
                  setStatus("Sent! Signature: " + sig);
                } catch (err) {
                  setError(err.message || "Withdraw failed.");
                }
                setConfirming(false);
              }
            },
              e("label", null, "Token"),
              e("select", {
                value: withdrawToken.symbol,
                onChange: e => setWithdrawToken(tokensList.find(t => t.symbol === e.target.value))
              },
                tokensList
                  .filter(t => t.symbol === "SOL" || t.symbol === "FIXR")
                  .map(t =>
                    e("option", { key: t.symbol, value: t.symbol }, t.symbol)
                  )
              ),
              e("label", null, "Solana Address"),
              e("input", {
                type: "text",
                required: true,
                value: withdrawAddress,
                onChange: e => setWithdrawAddress(e.target.value),
                placeholder: "Enter Solana address"
              }),
              e("label", null,
                `Amount (${withdrawToken.symbol})`,
                e("span", { style: { fontWeight: 400, color: "#bbb", marginLeft: 8 } },
                  `(Available: ${userBalance.toLocaleString(undefined, { maximumFractionDigits: withdrawToken.decimals })})`,
                  e("button", {
                    type: "button",
                    className: "max-button",
                    onClick: handleMax,
                    tabIndex: -1
                  }, "Max")
                )
              ),
              e("input", {
                type: "number",
                min: "0",
                step: 1 / Math.pow(10, withdrawToken.decimals),
                required: true,
                value: withdrawAmount,
                onChange: e => setWithdrawAmount(e.target.value),
                placeholder: `Amount in ${withdrawToken.symbol}`
              }),
              e("label", null, "Network"),
              e("input", {
                type: "text",
                value: "Solana",
                readOnly: true,
                style: { background: "#222" }
              }),
              e("button", { className: "modal-btn", type: "submit", disabled: confirming },
                confirming ? "Withdrawing..." : "Confirm Withdraw"
              )
            ),
            error && e("div", { className: "error" }, error),
            status && e("div", { className: "status" },
              status.includes("Signature: ")
                ? e("span", null,
                    status,
                    " ",
                    e("a", {
                      href: `https://solscan.io/tx/${status.split("Signature: ")[1]}`,
                      target: "_blank",
                      rel: "noopener noreferrer",
                      style: { color: "#a5caff" }
                    }, "View")
                  )
                : status
            )
          )
        );
      }

      function App() {
        // Wallet & provider
        const [provider, setProvider] = useState(null);
        const [walletConnected, setWalletConnected] = useState(false);
        const [publicKey, setPublicKey] = useState(null);

        // Balances and prices
        const [balances, setBalances] = useState({});
        const [prices, setPrices] = useState({});
        const [loading, setLoading] = useState(false);
        const [loadingPrices, setLoadingPrices] = useState(false);
        const [tokenMetadata, setTokenMetadata] = useState({}); // For token URI

        // Modal state: null or "deposit", "withdraw", "swap"
        const [activeModal, setActiveModal] = useState(null);

        // Messages and loading states
        const [error, setError] = useState("");
        const [status, setStatus] = useState("");
        const [withdrawing, setWithdrawing] = useState(false);
        const [swapping, setSwapping] = useState(false);
        const [loadingQuotes, setLoadingQuotes] = useState(false);

        // Swap form
        const [swapFromToken, setSwapFromToken] = useState(tokensList[0]);
        const [swapToToken, setSwapToToken] = useState(tokensList[1]);
        const [swapAmount, setSwapAmount] = useState("");
        const [slippage, setSlippage] = useState(0.5);

        const [routes, setRoutes] = useState([]);
        const [selectedRoute, setSelectedRoute] = useState(null);

        // QR ref
        const qrCanvasRef = useRef(null);

        // Phantom detection and connect button
        useEffect(() => {
          function detectProvider() {
            if (window.solana && window.solana.isPhantom) {
              setProvider(window.solana);
            } else {
              setProvider(null);
            }
          }
          detectProvider();
          window.addEventListener('photon#initialized', detectProvider);
          return () => {
            window.removeEventListener('photon#initialized', detectProvider);
          };
        }, []);

        // Connect wallet
        const connectWallet = useCallback(async () => {
          setError("");
          if (!provider) {
            setError("Phantom Wallet not found. Please install Phantom.");
            return;
          }
          try {
            const resp = await provider.connect();
            setPublicKey(new PublicKey(resp.publicKey.toString()));
            setWalletConnected(true);
            setError("");
            setStatus("");
          } catch (err) {
            setError("Wallet connection rejected or failed.");
          }
        }, [provider]);

        const disconnectWallet = async () => {
          if (!provider) return;
          try { await provider.disconnect(); } catch { }
          setWalletConnected(false);
          setPublicKey(null);
          setBalances({});
          setPrices({});
          setRoutes([]);
          setSelectedRoute(null);
          setStatus("");
          setError("");
          setSwapAmount("");
          setActiveModal(null);
        };

        useEffect(() => {
          const btn = document.getElementById("connectWalletBtn");
          if (!btn) return;
          btn.innerText = walletConnected && publicKey ? shortAddress(publicKey) : "Connect";
          btn.onclick = () => {
            if (walletConnected) disconnectWallet();
            else connectWallet();
          };
        }, [walletConnected, publicKey, connectWallet]);

        useEffect(() => {
          if (!provider) return;
          const onConnect = (pk) => {
            const address = typeof pk.toBase58 === 'function' ? pk.toBase58() : pk.toString();
            setPublicKey(new PublicKey(address));
            setWalletConnected(true);
            setError("");
            setStatus("");
            const btn = document.getElementById("connectWalletBtn");
            if (btn) btn.innerText = shortAddress(address);
          };
          const onDisconnect = () => {
            setWalletConnected(false);
            setPublicKey(null);
            setBalances({});
            setPrices({});
            setRoutes([]);
            setSelectedRoute(null);
            setError("");
            setStatus("");
            setSwapAmount("");
            const btn = document.getElementById("connectWalletBtn");
            if (btn) btn.innerText = "Connect";
            setActiveModal(null);
          };
          provider.on("connect", onConnect);
          provider.on("disconnect", onDisconnect);
          if (provider.isConnected && provider.publicKey) onConnect(provider.publicKey);
          return () => {
            provider.removeListener && provider.removeListener("connect", onConnect);
            provider.removeListener && provider.removeListener("disconnect", onDisconnect);
          };
        }, [provider]);

        // Fetch balances and prices (with loader)
        async function fetchAll() {
          setLoading(true);
          setError("");
          try {
            if (!walletConnected || !publicKey) {
              setBalances({});
              setPrices({});
              setLoading(false);
              setLoadingPrices(false);
              return;
            }
            const solLamports = await connection.getBalance(publicKey);
            const newBalances = { SOL: solLamports / 1e9 };

            await Promise.all(tokensList.map(async t => {
              if (!t.mint) return;
              try {
                const ata = await findAssociatedTokenAddress(publicKey, t.mint);
                const info = await connection.getParsedAccountInfo(ata);
                newBalances[t.symbol] = info.value?.data?.parsed?.info?.tokenAmount?.uiAmount || 0;
              } catch {
                newBalances[t.symbol] = 0;
              }
            }));

            setBalances(newBalances);

            // Fetch token metadata URI (if any)
            let md = {};
            await Promise.all(tokensList.map(async t => {
              if (t.metadataUri) {
                if (t.metadataUri.endsWith(".json")) {
                  // Try to fetch info.json (dummy handling)
                  try {
                    const resp = await axios.get(t.metadataUri);
                    md[t.symbol] = resp.data?.description || t.metadataUri;
                  } catch {
                    md[t.symbol] = t.metadataUri;
                  }
                } else {
                  md[t.symbol] = t.metadataUri;
                }
              } else {
                md[t.symbol] = "";
              }
            }));
            setTokenMetadata(md);

            // Price fetching
            setLoadingPrices(true);
            const cgIds = Object.values(cgMap).filter(Boolean).join(",");
            let pricesObj = {};
            if (cgIds) {
              const resp = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=${cgIds}&vs_currencies=usd`);
              Object.entries(cgMap).forEach(([sym, id]) => {
                pricesObj[sym] = id && resp.data[id]?.usd ? resp.data[id]?.usd : null;
              });
            } else {
              Object.keys(cgMap).forEach(sym => pricesObj[sym] = null);
            }
            setPrices(pricesObj);
            setLoadingPrices(false);
          } catch {
            setError("Error loading balances or prices.");
            setLoadingPrices(false);
          }
          setLoading(false);
        }

        // Re-fetch when wallet connects, modal closes, or status changes
        useEffect(() => {
          fetchAll();
          // eslint-disable-next-line
        }, [walletConnected, publicKey, activeModal, status]);

        // Reset swap form when opening swap modal
        useEffect(() => {
          if (activeModal === "swap") {
            setSwapAmount("");
            setSwapFromToken(tokensList[0]);
            setSwapToToken(tokensList[1]);
            setError("");
            setStatus("");
          }
        }, [activeModal]);

        const totalBalanceUSD = Object.entries(balances).reduce((a, [sym, bal]) => a + ((prices[sym] || 0) * bal), 0);

        function DepositModal() {
          useEffect(() => {
            if (qrCanvasRef.current && publicKey) {
              const qrString = `solana:${publicKey.toBase58()}`;
              QRCode.toCanvas(qrCanvasRef.current, qrString, { width: 180 });
            }
          }, [publicKey]);
          return e("div", { className: "overlay-bg", onClick: () => setActiveModal(null) },
            e("div", { className: "overlay-panel", onClick: e => e.stopPropagation(), role: "dialog", "aria-modal": "true", "aria-labelledby": "depositTitle" },
              e("div", { className: "overlay-header" },
                e("h2", { id: "depositTitle" }, "Deposit (SOL & SPL Tokens)"),
                e("button", { className: "overlay-close-btn", "aria-label": "Close", onClick: () => setActiveModal(null) }, "×")
              ),
              e("div", null,
                e("div", { id: "depositAddress" }, publicKey && publicKey.toBase58()),
                e("canvas", { ref: qrCanvasRef, id: "qrcode" }),
                e("small", null, "Send only SOL or SPL tokens to this address on the Solana network.")
              )
            )
          );
        }

        function SwapModal() {
          // Fetch quotes whenever swapAmount, from, or to changes
          useEffect(() => {
            async function fetchQuotes() {
              setLoadingQuotes(true);
              setRoutes([]);
              setSelectedRoute(null);
              if (!swapAmount || isNaN(Number(swapAmount)) || Number(swapAmount) <= 0) {
                setLoadingQuotes(false);
                return;
              }
              try {
                const inputMint = swapFromToken.mint ? swapFromToken.mint.toString() : SOL_MINT;
                const outputMint = swapToToken.mint ? swapToToken.mint.toString() : SOL_MINT;
                const amount = toBaseUnits(swapAmount, swapFromToken.decimals);

                const { data } = await axios.get(
                  `${JUPITER_API_BASE}/quote?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amount}&slippageBps=${Math.floor(slippage*100)}`
                );
                setRoutes(data.data || []);
                setSelectedRoute(data.data?.[0] || null);
              } catch {
                setRoutes([]);
                setSelectedRoute(null);
              }
              setLoadingQuotes(false);
            }
            if (swapFromToken && swapToToken && swapFromToken.symbol !== swapToToken.symbol) fetchQuotes();
          }, [swapFromToken, swapToToken, swapAmount, slippage]);

          // Filter token lists for dropdowns so user can't pick the same token for both
          const fromOptions = tokensList.filter(t => t.symbol !== swapToToken.symbol);
          const toOptions = tokensList.filter(t => t.symbol !== swapFromToken.symbol);

          return e("div", { className: "overlay-bg", onClick: () => setActiveModal(null) },
            e("div", { className: "overlay-panel", onClick: e => e.stopPropagation(), role: "dialog", "aria-modal": "true", "aria-labelledby": "swapTitle" },
              e("div", { className: "overlay-header" },
                e("h2", { id: "swapTitle" }, "Swap (Advanced Routes)"),
                e("button", { className: "overlay-close-btn", "aria-label": "Close", onClick: () => setActiveModal(null) }, "×")
              ),
              e("form", {
                onSubmit: async (ev) => {
                  ev.preventDefault();
                  setSwapping(true);
                  setError(""); setStatus("");
                  try {
                    if (!selectedRoute) throw new Error("No quote selected.");
                    // Get Jupiter swap transaction
                    const swapResp = await axios.post(
                      `${JUPITER_API_BASE}/swap`,
                      {
                        route: selectedRoute,
                        userPublicKey: publicKey.toString(),
                        wrapUnwrapSOL: true,
                        dynamicComputeUnitLimit: true
                      }
                    );
                    const swapTx = swapResp.data.swapTransaction;
                    const tx = solanaWeb3.Transaction.from(Buffer.from(swapTx, "base64"));
                    tx.feePayer = publicKey;
                    tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
                    const signed = await provider.signTransaction(tx);
                    const sig = await connection.sendRawTransaction(signed.serialize());
                    setStatus("Swapped! Signature: " + sig);
                  } catch (err) {
                    setError(err.message || "Swap failed.");
                  }
                  setSwapping(false);
                }
              },
                e("label", null, "From"),
                e("select", {
                  value: swapFromToken.symbol,
                  onChange: e => {
                    const tok = tokensList.find(t => t.symbol === e.target.value);
                    setSwapFromToken(tok);
                    if (tok.symbol === swapToToken.symbol) {
                      const nextTo = tokensList.find(t => t.symbol !== tok.symbol) || tokensList[0];
                      setSwapToToken(nextTo);
                    }
                  }
                },
                  fromOptions.map(t =>
                    e("option", { key: t.symbol, value: t.symbol }, t.symbol)
                  )
                ),
                e("label", null, "To"),
                e("select", {
                  value: swapToToken.symbol,
                  onChange: e => {
                    const tok = tokensList.find(t => t.symbol === e.target.value);
                    setSwapToToken(tok);
                    if (tok.symbol === swapFromToken.symbol) {
                      setSwapFromToken(tokensList.find(t => t.symbol !== tok.symbol) || tokensList[0]);
                    }
                  }
                },
                  toOptions.map(t =>
                    e("option", { key: t.symbol, value: t.symbol }, t.symbol)
                  )
                ),
                e("label", null, "Amount"),
                e("input", {
                  type: "number", min: "0", required: true, value: swapAmount,
                  onChange: e => setSwapAmount(e.target.value)
                }),
                e("label", null, "Slippage %"),
                e("input", {
                  type: "number", min: "0.1", max: "3", step: "0.1",
                  value: slippage,
                  onChange: e => setSlippage(Number(e.target.value))
                }),
                loadingQuotes ? e("div", null, e("span", null, "Getting quotes..."), e("span", { className: "dot-loader" }, e("span"), e("span"), e("span"))) :
                  routes.length > 0 ? e("div", null,
                    e("div", { style: { marginBottom: "8px", color: "#aaa", fontSize: "0.97rem" } }, "Select a route:"),
                    routes.map((route, idx) =>
                      e("div", {
                        className: "route-option" + (selectedRoute === route ? " selected" : ""),
                        key: idx,
                        tabIndex: 0,
                        onClick: () => setSelectedRoute(route),
                        onKeyDown: evt => { if (evt.key === "Enter") setSelectedRoute(route); }
                      },
                        e("div", { className: "route-info" },
                          "Output: ",
                          (route.outAmount / 10 ** swapToToken.decimals).toLocaleString(undefined, { maximumFractionDigits: swapToToken.decimals }),
                          " ", swapToToken.symbol
                        ),
                        e("div", { className: "route-amm" },
                          "Path: ", route.marketInfos.map(m => m.amm.label).join(" → ")
                        ),
                        e("div", null,
                          "Min received: ",
                          (route.amountOutWithSlippage / 10 ** swapToToken.decimals).toLocaleString(undefined, { maximumFractionDigits: swapToToken.decimals }),
                          " ", swapToToken.symbol
                        ),
                        e("div", null, "Price Impact: " + (route.priceImpactPct * 100).toFixed(2) + "%")
                      )
                    )
                  ) :
                  e("div", null, "No quote"),
                e("button", { className: "modal-btn", type: "submit", disabled: swapping || !selectedRoute }, swapping ? "Swapping..." : "Confirm Swap")
              ),
              error && e("div", { className: "error" }, error),
              status && e("div", { className: "status" },
                status.includes("Signature: ")
                  ? e("span", null,
                      status,
                      " ",
                      e("a", {
                        href: `https://solscan.io/tx/${status.split("Signature: ")[1]}`,
                        target: "_blank",
                        rel: "noopener noreferrer",
                        style: {color: "#a5caff"}
                      }, "View")
                    )
                  : status
              )
            )
          );
        }

        return e(React.Fragment, null,
          error && e("div", { className: "error" }, error),
          status && e("div", { className: "status" },
            status.includes("Signature: ")
              ? e("span", null,
                  status,
                  " ",
                  e("a", {
                    href: `https://solscan.io/tx/${status.split("Signature: ")[1]}`,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    style: {color: "#a5caff"}
                  }, "View")
                )
              : status
          ),
          e("div", { id: "totalBalance" }, walletConnected
            ? (loading ? e("span", null, "Loading...", e("span", { className: "dot-loader" }, e("span"), e("span"), e("span"))) : `≈ $${totalBalanceUSD.toFixed(2)} USD`)
            : "Connect wallet to view balance"
          ),
          e("div", { className: "refresh-bar" },
            walletConnected && e("button", {
              className: "refresh-btn",
              onClick: fetchAll,
              disabled: loading
            }, loading ? e("span", null, "Refreshing...", e("span", { className: "dot-loader" }, e("span"), e("span"), e("span"))) : "Refresh Balances")
          ),
          e("div", { className: "tokens-list" },
            tokensList.map(token =>
              e("div", { key: token.symbol, className: "token-item" },
                e(TokenLogo, { token }),
                e("div", { className: "token-info" },
                  e("div", { className: "token-symbol" }, token.symbol),
                  e("div", { className: "token-balance" },
                    walletConnected ? `${(balances[token.symbol] || 0).toLocaleString(undefined, { maximumFractionDigits: token.decimals })}` : "-"
                  ),
                  e("div", { className: "token-price" },
                    loadingPrices
                      ? e("span", null, "Fetching price", e("span", { className: "dot-loader" }, e("span"), e("span"), e("span")))
                      : (prices[token.symbol] == null
                        ? "N/A"
                        : prices[token.symbol]
                          ? `$${prices[token.symbol]}`
                          : "-")
                  ),
                  token.metadataUri && e("div", { className: "token-uri" },
                    "URI: ", e("a", { href: token.metadataUri, style: { color: "#7fbbff" }, target: "_blank", rel: "noopener noreferrer" }, token.metadataUri)
                  )
                )
              )
            )
          ),
          walletConnected && e("div", { className: "button-bar" },
            e("button", { onClick: () => setActiveModal("deposit") }, "Deposit"),
            e("button", { onClick: () => setActiveModal("withdraw") }, "Withdraw"),
            e("button", { onClick: () => setActiveModal("swap") }, "Swap")
          ),
          activeModal === "deposit" && e(DepositModal),
          activeModal === "withdraw" && e(WithdrawModal),
          activeModal === "swap" && e(SwapModal)
        );
      }

      ReactDOM.render(e(App), document.getElementById("root"));
    })();
  </script>
</body>
</html>

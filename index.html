 <!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FIXORIUM Wallet</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.2/lib/index.iife.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bn.js/5.2.0/bn.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body, input, button, select {
      font-family: Arial, sans-serif !important;
      font-size: 13px !important;
    }
    body {
      margin: 0;
      background-color: #121212;
      color: #eee;
      height: 100vh;
      user-select: none;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    header {
      background-color: #1e90ff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      position: relative;
      color: white;
      user-select: none;
    }
    #logo-left { font-weight: 900; font-size: 1.4rem; letter-spacing: 1.2px; user-select: text; cursor: default; white-space: nowrap; }
    #logo-center {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
      user-select: none; pointer-events: none; width: 400px; height: 600px;
      background: url("https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/solana/info/logo.png") no-repeat center;
      background-size: contain; opacity: 0.05; z-index: 0;
    }
    #connectWalletBtn {
      background-color: #005ecb; font-size: 0.8rem; padding: 6px 12px; border-radius: 8px;
      font-weight: 700; min-width: 100px; text-align: center; white-space: nowrap;
      user-select: none; cursor: pointer; border: none; color: white;
      transition: background-color 0.2s ease; position: relative; z-index: 10;
    }
    #connectWalletBtn:hover:not([disabled]) { background-color: #004099; }
    #connectWalletBtn[disabled] { background-color: #444444; cursor: default; }
    main { flex-grow: 1; overflow-y: auto; padding: 16px; position: relative; }
    #totalBalance { font-size: 2.8rem; font-weight: 900; text-align: center; margin-bottom: 15px; user-select: text; min-height:56px;}
    .tokens-list {
      max-height: calc(100vh - 200px); overflow-y: auto; margin: 0 auto; max-width: 520px;
      border: 1px solid #333; border-radius: 14px; background: #1e2a38; padding: 12px 16px; box-shadow: 0 0 10px #1e90ff88;
    }
    .token-item { background: #2a3a54; margin-bottom: 10px; border-radius: 10px; display: flex; align-items: center; padding: 8px 12px; color: #eee; cursor: pointer; user-select: none; }
    .token-item:focus-visible { outline: 2px solid #1e90ff; outline-offset: 2px; }
    .token-info { flex-grow: 1; display: flex; flex-direction: column; user-select: text; }
    .token-symbol, .token-balance, .token-price { font-size: 13px !important; }
    .token-symbol { font-weight: 700; margin-bottom: 4px; }
    .token-balance, .token-price { }
    .token-price { color: #a5caff; display: flex; align-items: center; }
    .button-bar {
      position: fixed; top: 50px; right: 20px; z-index: 20; display: flex; flex-direction: column; gap: 10px;
    }
    .button-bar button {
      min-width: 110px; padding: 8px 12px; font-size: 0.95rem; border-radius: 8px; font-weight: 700;
      background-color: #1e90ff; border: none; color: white; user-select: none; cursor: pointer; transition: background-color 0.25s ease;
    }
    .button-bar button:hover { background-color: #004c9e; }
    [hidden] { display: none !important; }
    .overlay-bg {
      position: fixed; inset: 0; background-color: #000c; backdrop-filter: blur(2px); user-select: none; z-index: 40;
      display: flex; justify-content: center; align-items: center;
    }
    .overlay-panel {
      background: #1e2a38; border-radius: 16px; box-shadow: 0 0 20px #1e90ffaa; max-width: 480px; width: 90%;
      max-height: 80vh; overflow-y: auto; padding: 24px 28px 28px; color: #eee; user-select: text; position: relative; font-size: 14px;
    }
    .overlay-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    .overlay-header h2 { margin: 0; font-size: 1.5rem; font-weight: 900; user-select: text; }
    .overlay-close-btn {
      background: transparent; border: none; font-size: 1.6rem; color: #eee; user-select: none;
      cursor: pointer; padding: 0; line-height: 1; font-weight: 700; transition: color 0.2s ease;
    }
    .overlay-close-btn:hover { color: #1e90ff; }
    label { font-weight: 600; margin-top: 12px; display: block; color: #ccc; user-select: text; }
    input[type="text"], input[type="number"], select {
      width: 100%; padding: 9px 12px; margin-top: 6px; font-size: 1rem; border-radius: 8px;
      border: 1.5px solid #444; background-color: #121212; color: #eee; box-sizing: border-box; transition: border-color 0.25s ease;
    }
    input[type="text"]:focus, input[type="number"]:focus, select:focus {
      outline: none; border-color: #1e90ff; box-shadow: 0 0 8px #1e90ff80;
    }
    button.modal-btn { width: 100%; margin-top: 18px; padding: 12px; font-size: 1rem; font-weight: 700; border: none; border-radius: 8px; cursor: pointer; user-select: none; background-color: #1e90ff; color: white; transition: background-color 0.3s ease; }
    button.modal-btn:hover:not([disabled]) { background-color: #004c9e; }
    button.modal-btn[disabled] { background-color: #444444; cursor: default; }
    #depositAddress { font-family: monospace; font-size: 1rem; word-break: break-all; margin-bottom: 12px; user-select: all; }
    #qrcode { display: block; margin: 0 auto 15px; max-width: 180px; max-height: 180px; user-select: none; pointer-events: none; }
    .max-button { position: absolute; right: 12px; top: 38px; background: #1e90ff; border: none; color: white; padding: 4px 8px; font-weight: 700; border-radius: 6px; cursor: pointer; user-select: none; font-size: 0.9rem; transition: background-color 0.25s ease; }
    .max-button:hover { background-color: #004c9e; }
    .input-wrapper { position: relative; }
    .slippage-range { width: 100%; margin-top: 8px; }
    .modal-section small { display: block; margin: 6px 0 8px 0; color: #8899bb; font-size: 0.9rem; user-select: text; }
    .error { color: #ff4d4f; font-weight: 700; margin-top: 14px; text-align: center; user-select: text; }
    .status { color: #1e90ff; font-weight: 700; margin-top: 14px; text-align: center; user-select: text; }
    .route-option { border: 1.5px solid #333; border-radius: 8px; margin: 8px 0; padding: 8px 10px; cursor: pointer; transition: border-color 0.2s; }
    .route-option.selected { border: 2px solid #1e90ff; background: #22344a; }
    .route-info { font-size: 0.97rem; margin-bottom: 2px; }
    .route-amm { color: #a5caff; font-size: 0.92rem; }
    .dot-loader {
      display: inline-flex;
      align-items: center;
      height: 14px;
      margin-left: 8px;
      vertical-align: middle;
    }
    .dot-loader span {
      display: block;
      width: 7px;
      height: 7px;
      background: #1e90ff;
      border-radius: 50%;
      margin-right: 3px;
      animation: dot-blink 1.1s infinite both;
    }
    .dot-loader span:nth-child(2) {
      animation-delay: .2s;
    }
    .dot-loader span:nth-child(3) {
      animation-delay: .4s;
    }
    @keyframes dot-blink {
      0%, 80%, 100% { opacity: 0.2; }
      40% { opacity: 1; }
    }
    .buy-btn, .sell-btn {
      font-size: 14px;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      padding: 8px 20px;
      margin-left: 8px;
      margin-top: 4px;
      cursor: pointer;
      background: #1e90ff;
      color: #fff;
      animation: none;
      outline: none;
    }
    .buy-btn.blink, .sell-btn.blink {
      animation: blink-btn 0.7s infinite alternate;
    }
    .buy-btn { background: #16c784; }
    .sell-btn { background: #ea3943; }
    @keyframes blink-btn {
      0% { box-shadow: 0 0 0 0 #fff2; }
      100% { box-shadow: 0 0 12px 2px #fff5; }
    }
  </style>
</head>
<body>
  <header>
    <div id="logo-left">FIXORIUM</div>
    <button id="connectWalletBtn" title="Connect / Disconnect Wallet">Connect</button>
    <div id="logo-center"></div>
  </header>
  <main>
    <div id="root"></div>
  </main>
  <script type="text/javascript">
    (() => {
      const e = React.createElement;
      const { useState, useEffect, useCallback, useRef } = React;

      // --- CONFIG ---
      const tokensList = [
        { symbol: "SOL", name: "Solana", decimals: 9, mint: null },
        { symbol: "USDC", name: "USD Coin", decimals: 6, mint: new solanaWeb3.PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v") },
        { symbol: "USDT", name: "Tether USD", decimals: 6, mint: new solanaWeb3.PublicKey("Es9vMFrzaCER7N1TvjVqauDziYbPEmxW5M9VpX1TTd8C") },
        { symbol: "FIXR", name: "FixerCoin", decimals: 9, mint: new solanaWeb3.PublicKey("D2mGkp5D43jirFeapx8UZmpiH7FaWeX1eUWy94q1F2hD") }
      ];
      const cgMap = {
        SOL: "solana",
        USDC: "usd-coin",
        USDT: "tether",
        FIXR: "" // Set your own coingecko id if available
      };

      const connection = new solanaWeb3.Connection("https://solana-api.projectserum.com", "confirmed");
      const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
      const ASSOCIATED_TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("ATokenGPvR1HuTRHqpPDp7HHTRmAg3zRk6USH3UUZsM");
      const SOL_MINT = "So11111111111111111111111111111111111111112";
      const JUPITER_API_BASE = "https://quote-api.jup.ag/v6";

      async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {
        return (
          await solanaWeb3.PublicKey.findProgramAddress(
            [walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()],
            ASSOCIATED_TOKEN_PROGRAM_ID
          )
        )[0];
      }
      function toBaseUnits(amountStr, decimals) {
        try {
          const val = parseFloat(amountStr);
          if (isNaN(val) || val <= 0) return 0;
          return Math.round(val * 10 ** decimals);
        } catch {
          return 0;
        }
      }

      // Simulated bot signals (replace with your own logic or endpoint)
      function useBotSignals(prices) {
        // Random buy/sell signals for demonstration
        const [signals, setSignals] = useState({});
        useEffect(() => {
          const interval = setInterval(() => {
            setSignals({
              SOL: Math.random() > 0.7 ? "BUY" : Math.random() > 0.7 ? "SELL" : "",
              USDC: "",
              USDT: "",
              FIXR: Math.random() > 0.5 ? "BUY" : ""
            });
          }, 4000);
          return () => clearInterval(interval);
        }, []);
        return signals;
      }

      function App() {
        const [provider, setProvider] = useState(null);
        const [walletConnected, setWalletConnected] = useState(false);
        const [publicKey, setPublicKey] = useState(null);
        const [balances, setBalances] = useState({});
        const [prices, setPrices] = useState({});
        const [loading, setLoading] = useState(false);
        const [loadingPrices, setLoadingPrices] = useState(false);
        const [activeModal, setActiveModal] = useState(null);
        const [error, setError] = useState("");
        const [status, setStatus] = useState("");
        const [swapFromToken, setSwapFromToken] = useState(tokensList[0]);
        const [swapToToken, setSwapToToken] = useState(tokensList[1]);
        const [swapAmount, setSwapAmount] = useState("");
        const [routes, setRoutes] = useState([]);
        const [selectedRoute, setSelectedRoute] = useState(null);
        const [swapping, setSwapping] = useState(false);
        const [loadingQuotes, setLoadingQuotes] = useState(false);
        const signals = useBotSignals(prices);

        // Phantom detection
        useEffect(() => {
          function detectProvider() {
            if (window.solana && window.solana.isPhantom) {
              setProvider(window.solana);
            } else {
              setProvider(null);
            }
          }
          detectProvider();
          window.addEventListener('photon#initialized', detectProvider);
          return () => window.removeEventListener('photon#initialized', detectProvider);
        }, []);

        // Wallet connection
        const connectWallet = useCallback(async () => {
          setError("");
          if (!provider) {
            setError("Phantom Wallet not found. Please install Phantom.");
            return;
          }
          try {
            const resp = await provider.connect();
            setPublicKey(new solanaWeb3.PublicKey(resp.publicKey.toString()));
            setWalletConnected(true);
            setError("");
            setStatus("");
          } catch (err) {
            setError("Wallet connection rejected or failed.");
          }
        }, [provider]);
        const disconnectWallet = async () => {
          if (!provider) return;
          try { await provider.disconnect(); } catch { }
          setWalletConnected(false);
          setPublicKey(null);
          setBalances({});
          setPrices({});
          setRoutes([]);
          setSelectedRoute(null);
          setStatus("");
          setError("");
          setSwapAmount("");
          setActiveModal(null);
        };

        useEffect(() => {
          const btn = document.getElementById("connectWalletBtn");
          if (!btn) return;
          btn.innerText = walletConnected && publicKey ? (publicKey.toBase58().slice(0, 4) + "..." + publicKey.toBase58().slice(-4)) : "Connect";
          btn.onclick = () => {
            if (walletConnected) disconnectWallet();
            else connectWallet();
          };
        }, [walletConnected, publicKey, connectWallet]);

        useEffect(() => {
          if (!provider) return;
          const onConnect = (pk) => {
            const address = typeof pk.toBase58 === 'function' ? pk.toBase58() : pk.toString();
            setPublicKey(new solanaWeb3.PublicKey(address));
            setWalletConnected(true);
            setError("");
            setStatus("");
            const btn = document.getElementById("connectWalletBtn");
            if (btn) btn.innerText = address.slice(0, 4) + "..." + address.slice(-4);
          };
          const onDisconnect = () => {
            setWalletConnected(false);
            setPublicKey(null);
            setBalances({});
            setPrices({});
            setRoutes([]);
            setSelectedRoute(null);
            setError("");
            setStatus("");
            setSwapAmount("");
            const btn = document.getElementById("connectWalletBtn");
            if (btn) btn.innerText = "Connect";
            setActiveModal(null);
          };
          provider.on("connect", onConnect);
          provider.on("disconnect", onDisconnect);
          if (provider.isConnected && provider.publicKey) onConnect(provider.publicKey);
          return () => {
            provider.removeListener && provider.removeListener("connect", onConnect);
            provider.removeListener && provider.removeListener("disconnect", onDisconnect);
          };
        }, [provider]);

        // Fetch balances and prices
        async function fetchAll() {
          setLoading(true);
          setError("");
          try {
            if (!walletConnected || !publicKey) {
              setBalances({});
              setPrices({});
              setLoading(false);
              setLoadingPrices(false);
              return;
            }
            const solLamports = await connection.getBalance(publicKey);
            const newBalances = { SOL: solLamports / 1e9 };

            await Promise.all(tokensList.map(async t => {
              if (!t.mint) return;
              try {
                const ata = await findAssociatedTokenAddress(publicKey, t.mint);
                const info = await connection.getParsedAccountInfo(ata);
                newBalances[t.symbol] = info.value?.data?.parsed?.info?.tokenAmount?.uiAmount || 0;
              } catch {
                newBalances[t.symbol] = 0;
              }
            }));

            setBalances(newBalances);

            // Price fetching
            setLoadingPrices(true);
            const cgIds = Object.values(cgMap).filter(Boolean).join(",");
            let pricesObj = {};
            if (cgIds) {
              const resp = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=${cgIds}&vs_currencies=usd`);
              Object.entries(cgMap).forEach(([sym, id]) => {
                pricesObj[sym] = id && resp.data[id]?.usd ? resp.data[id]?.usd : null;
              });
            } else {
              Object.keys(cgMap).forEach(sym => pricesObj[sym] = null);
            }
            setPrices(pricesObj);
            setLoadingPrices(false);
          } catch {
            setError("Error loading balances or prices.");
            setLoadingPrices(false);
          }
          setLoading(false);
        }

        // Show tokens and buttons even while loading, but with loader for balance/price
        useEffect(() => {
          if (walletConnected) fetchAll();
        }, [walletConnected, publicKey, activeModal, status]);

        // --- SWAP ---

        // Slippage fixed at 0.05%
        const slippage = 0.05;

        // Fetch swap routes (auto-detecting best platform via Jupiter aggregator)
        useEffect(() => {
          async function fetchQuotes() {
            setLoadingQuotes(true);
            setRoutes([]);
            setSelectedRoute(null);
            if (!swapAmount || isNaN(Number(swapAmount)) || Number(swapAmount) <= 0) {
              setLoadingQuotes(false);
              return;
            }
            try {
              const inputMint = swapFromToken.mint ? swapFromToken.mint.toString() : SOL_MINT;
              const outputMint = swapToToken.mint ? swapToToken.mint.toString() : SOL_MINT;
              const amount = toBaseUnits(swapAmount, swapFromToken.decimals);
              const { data } = await axios.get(
                `${JUPITER_API_BASE}/quote?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amount}&slippageBps=${Math.floor(slippage*100)}`
              );
              setRoutes(data.data || []);
              setSelectedRoute(data.data?.[0] || null);
            } catch {
              setRoutes([]);
              setSelectedRoute(null);
            }
            setLoadingQuotes(false);
          }
          if (activeModal === "swap" && swapFromToken && swapToToken && swapFromToken.symbol !== swapToToken.symbol) fetchQuotes();
        }, [swapFromToken, swapToToken, swapAmount, activeModal]);

        // Main rendering
        return e(React.Fragment, null,
          error && e("div", { className: "error" }, error),
          status && e("div", { className: "status" }, status),
          e("div", { id: "totalBalance" },
            walletConnected
              ? (loading
                ? e("span", null, e("span", { className: "dot-loader" }, e("span"), e("span"), e("span")))
                : null)
              : null
          ),
          walletConnected && e("div", { className: "tokens-list" },
            tokensList.map(token =>
              e("div", { key: token.symbol, className: "token-item" },
                e("div", { className: "token-info" },
                  e("div", { className: "token-symbol" }, token.name),
                  e("div", { className: "token-balance" },
                    loading
                      ? e("span", { className: "dot-loader" }, e("span"), e("span"), e("span"))
                      : (balances[token.symbol] || 0).toLocaleString(undefined, { maximumFractionDigits: token.decimals })
                  ),
                  e("div", { className: "token-price" },
                    loadingPrices
                      ? e("span", null, e("span", { className: "dot-loader" }, e("span"), e("span"), e("span")))
                      : (prices[token.symbol] == null
                        ? "N/A"
                        : prices[token.symbol]
                          ? `$${prices[token.symbol]}`
                          : "-"),
                    signals[token.symbol] === "BUY" && e("button", { className: "buy-btn blink", tabIndex: -1 }, "BUY"),
                    signals[token.symbol] === "SELL" && e("button", { className: "sell-btn blink", tabIndex: -1 }, "SELL")
                  )
                )
              )
            )
          ),
          walletConnected && e("div", { className: "button-bar" },
            e("button", { onClick: () => setActiveModal("swap") }, "Swap"),
            e("button", { onClick: () => setActiveModal("withdraw") }, "Withdraw"),
            e("button", { onClick: () => setActiveModal("deposit") }, "Deposit")
          ),
          // Deposit/Withdraw/Swap modals
          activeModal === "deposit" && e(() => {
            const qrCanvasRef = useRef(null);
            useEffect(() => {
              if (qrCanvasRef.current && publicKey) {
                const qrString = `solana:${publicKey.toBase58()}`;
                window.QRCode.toCanvas(qrCanvasRef.current, qrString, { width: 180 });
              }
            }, [publicKey]);
            return e("div", { className: "overlay-bg", onClick: () => setActiveModal(null) },
              e("div", { className: "overlay-panel", onClick: e => e.stopPropagation(), role: "dialog", "aria-modal": "true", "aria-labelledby": "depositTitle" },
                e("div", { className: "overlay-header" },
                  e("h2", { id: "depositTitle" }, "Deposit"),
                  e("button", { className: "overlay-close-btn", "aria-label": "Close", onClick: () => setActiveModal(null) }, "×")
                ),
                e("div", null,
                  e("div", { id: "depositAddress" }, publicKey && publicKey.toBase58()),
                  e("canvas", { ref: qrCanvasRef, id: "qrcode" }),
                  e("small", null, "Send only SOL or SPL tokens to this address on Solana.")
                )
              )
            );
          }),
          activeModal === "withdraw" && e(() => {
            // WithdrawModal should be implemented here
            return e("div", { className: "overlay-bg", onClick: () => setActiveModal(null) },
              e("div", { className: "overlay-panel", onClick: e => e.stopPropagation() },
                e("div", { className: "overlay-header" },
                  e("h2", null, "Withdraw"),
                  e("button", { className: "overlay-close-btn", onClick: () => setActiveModal(null) }, "×")
                ),
                e("div", null, "Withdraw UI goes here")
              )
            );
          }),
          activeModal === "swap" && e(() => {
            // Slippage always 0.05, no input, best platform auto-detected
            return e("div", { className: "overlay-bg", onClick: () => setActiveModal(null) },
              e("div", { className: "overlay-panel", onClick: e => e.stopPropagation() },
                e("div", { className: "overlay-header" },
                  e("h2", null, "Swap"),
                  e("button", { className: "overlay-close-btn", onClick: () => setActiveModal(null) }, "×")
                ),
                e("form", {
                  onSubmit: async (ev) => {
                    ev.preventDefault();
                    setSwapping(true);
                    setError(""); setStatus("");
                    try {
                      if (!selectedRoute) throw new Error("No swap route selected.");
                      const swapResp = await axios.post(
                        `${JUPITER_API_BASE}/swap`,
                        {
                          route: selectedRoute,
                          userPublicKey: publicKey.toString(),
                          wrapUnwrapSOL: true,
                          dynamicComputeUnitLimit: true
                        }
                      );
                      const tx = solanaWeb3.Transaction.from(Buffer.from(swapResp.data.swapTransaction, "base64"));
                      tx.feePayer = publicKey;
                      tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
                      const signed = await provider.signTransaction(tx);
                      const sig = await connection.sendRawTransaction(signed.serialize());
                      setStatus("Swapped! Signature: " + sig);
                    } catch (err) {
                      setError(err.message || "Swap failed.");
                    }
                    setSwapping(false);
                  }
                },
                  e("label", null, "From"),
                  e("select", {
                    value: swapFromToken.symbol,
                    onChange: e => {
                      const tok = tokensList.find(t => t.symbol === e.target.value);
                      setSwapFromToken(tok);
                      if (tok.symbol === swapToToken.symbol) {
                        const nextTo = tokensList.find(t => t.symbol !== tok.symbol) || tokensList[0];
                        setSwapToToken(nextTo);
                      }
                    }
                  },
                    tokensList.filter(t => t.symbol !== swapToToken.symbol)
                      .map(t => e("option", { key: t.symbol, value: t.symbol }, t.symbol))
                  ),
                  e("label", null, "To"),
                  e("select", {
                    value: swapToToken.symbol,
                    onChange: e => {
                      const tok = tokensList.find(t => t.symbol === e.target.value);
                      setSwapToToken(tok);
                      if (tok.symbol === swapFromToken.symbol) {
                        setSwapFromToken(tokensList.find(t => t.symbol !== tok.symbol) || tokensList[0]);
                      }
                    }
                  },
                    tokensList.filter(t => t.symbol !== swapFromToken.symbol)
                      .map(t => e("option", { key: t.symbol, value: t.symbol }, t.symbol))
                  ),
                  e("label", null, "Amount"),
                  e("input", {
                    type: "number", min: "0", required: true, value: swapAmount,
                    onChange: e => setSwapAmount(e.target.value)
                  }),
                  loadingQuotes ? e("div", null, e("span", { className: "dot-loader" }, e("span"), e("span"), e("span"))) :
                    routes.length > 0 ? e("div", null,
                      routes.map((route, idx) =>
                        e("div", {
                          className: "route-option" + (selectedRoute === route ? " selected" : ""),
                          key: idx,
                          tabIndex: 0,
                          onClick: () => setSelectedRoute(route),
                          onKeyDown: evt => { if (evt.key === "Enter") setSelectedRoute(route); }
                        },
                          e("div", { className: "route-info" },
                            "Output: ",
                            (route.outAmount / 10 ** swapToToken.decimals).toLocaleString(undefined, { maximumFractionDigits: swapToToken.decimals }),
                            " ", swapToToken.symbol
                          ),
                          e("div", null, "Best route platform: ", route.marketInfos[0]?.amm.label || "-")
                        )
                      )
                    )
                    : e("div", null, "No route"),
                  e("button", { className: "modal-btn", type: "submit", disabled: swapping || !selectedRoute }, swapping ? e("span", { className: "dot-loader" }, e("span"), e("span"), e("span")) : "Confirm Swap")
                ),
                error && e("div", { className: "error" }, error),
                status && e("div", { className: "status" }, status)
              )
            );
          })
        );
      }

      ReactDOM.render(e(App), document.getElementById("root"));
    })();
  </script>
</body>
</html>

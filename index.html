 <!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FIXORIUM Wallet</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.2/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    body { margin:0; background:#0e1217; color:#eee; font-family:Arial,sans-serif; }
    header { display:flex; justify-content:space-between; align-items:center; background:#0b1015; padding:10px 20px; }
    #logo-left { font-size:1.5rem; font-weight:700; color:#00ffa8; }
    #wallet-btn-row { display:flex;gap:7px; }
    #browserWalletBtn, #phantomWalletBtn {
      background:#00ffa8; border:none; color:#121212; font-weight:700; padding:7px 13px; border-radius:6px; cursor:pointer; min-width:68px; font-size:1rem;
      transition: background 0.18s;
    }
    #phantomWalletBtn { background: #2e2c47; color:#00ffa8; border:1.3px solid #00ffa8; }
    #browserWalletBtn:hover { background:#00cc7a; }
    #phantomWalletBtn:hover { background:#00ffa8; color:#0e1217; }
    main { max-width:900px; margin:0 auto; padding:18px 8px 80px; }
    #totalBalance { font-size:1.3rem; margin-bottom:15px; font-weight:700; color:#00ff99; text-align:center; min-height:2em; }
    .tokens-list {
      display:grid;
      grid-template-columns:repeat(auto-fill,minmax(88px,1fr));
      gap:10px;
      margin-bottom:23px;
    }
    .token-item {
      background:#181c22;
      border-radius:11px;
      box-shadow:0 1px 6px #00ffa842;
      display:flex;flex-direction:column;align-items:center;user-select:none;
      padding:9px 2px 8px;
      justify-content:center;
      min-height:63px; min-width:70px; max-width:90px;
      transition: box-shadow .13s;
      font-size:0.98rem;
    }
    .token-item:hover { box-shadow:0 1px 12px #00ffa844; }
    .token-symbol { font-weight:700; font-size:0.98rem; color:#00ffa8; margin-bottom:3px; text-align:center; }
    .token-balance, .token-price { font-size:0.91rem; white-space:nowrap; display:flex;align-items:center;gap:4px; }
    .buy-btn, .sell-btn { border:1.2px solid; border-radius:10px; padding:1px 6px;font-weight:700; font-size:0.77rem;user-select:none;pointer-events:none;}
    .buy-btn { color:#16c784; border-color:#16c784; background:transparent; }
    .sell-btn { color:#ea3943; border-color:#ea3943; background:transparent; }
    .blink { animation:blink 1.3s linear infinite; }
    @keyframes blink {0%,100%{opacity:1;} 50%{opacity:.35;}}
    .dot-loader { display:inline-flex; gap:4px; user-select:none; }
    .dot-loader span { background:#0ee; width:6px; height:6px; border-radius:50%;display:inline-block;animation:bounce 1.2s infinite ease-in-out;}
    .dot-loader span:nth-child(2){animation-delay:.15s;}
    .dot-loader span:nth-child(3){animation-delay:.3s;}
    @keyframes bounce{0%,80%,100%{transform:scale(0);}40%{transform:scale(1);}}
    .overlay-bg {position:fixed;inset:0;background:rgba(5,10,15,0.83);backdrop-filter:blur(3px);z-index:1500;display:flex;justify-content:center;align-items:center;}
    .overlay-panel {background:#0f1530;border-radius:14px;box-shadow:0 1em 3em rgba(0,255,102,0.35);padding:18px 15px 22px;width:90%;max-width:330px;max-height:97vh;overflow-y:auto;}
    .overlay-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;}
    .overlay-header h2{margin:0;font-weight:700;font-size:1.15rem;color:#00ff99;}
    .overlay-close-btn{background:transparent;border:none;color:#00ff99;font-weight:900;font-size:1.45rem;cursor:pointer;}
    .modal-btn {margin-top:12px;cursor:pointer;background:linear-gradient(135deg,#00c77f 0%,#00ff99 100%);border:none;border-radius:10px;font-weight:700;font-size:1rem;padding:9px;color:#121212;width:100%;}
    .modal-btn:disabled{opacity:0.5;}
    .modal-btn:hover:not(:disabled){background:linear-gradient(135deg,#00ff99 0%,#00c77f 100%);}
    .error{background:#550000b3;padding:8px 10px;margin-bottom:8px;border-radius:8px;color:#ff9999;font-weight:700;text-align:center;}
    .status{background:#004400b3;padding:8px 10px;margin-bottom:8px;border-radius:8px;color:#a8ffaa;font-weight:700;text-align:center;}
    #depositAddress { font-family:monospace;word-break:break-all;margin-top:3px;margin-bottom:8px;font-size:0.9rem;border-radius:6px;background:#151c2b;padding:5px 8px;user-select:text;}
    #qrcode { margin:9px auto 0; display:block; max-width:120px; width:100%; height:auto; user-select:none; }
    .fixed-button-bar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 3000;
      background: rgba(14,18,23,0.97);
      box-shadow: 0 -1px 7px #00ffa84d;
      display: flex;
      justify-content: center;
      gap: 7px;
      padding: 7px 3px 7px;
    }
    .fixed-button-bar button {
      cursor:pointer; background:linear-gradient(135deg,#00c77f 0%,#00ff99 100%); border:none; border-radius:10px; font-weight:700; font-size:0.92rem; padding:6px 12px; color:#121212; box-shadow:0 1px 3px #004e3b;min-width:54px;
      transition: background 0.19s;
    }
    .fixed-button-bar button:hover:not(:disabled) { background:linear-gradient(135deg,#00ff99 0%,#00c77f 100%);}
    .fixed-button-bar button:disabled{opacity:.5;cursor:default;}
    .form-row { display:flex; gap:7px; align-items:center; }
    .input-max-btn-wrapper { display:flex; align-items:center; gap:6px; }
    .input-max-btn {
      font-size:0.8rem; background:#00ffa8; border:none; color:#151c2b; font-weight:700; border-radius:7px; padding:3px 10px; margin-left:3px; cursor:pointer; transition: background 0.2s;
    }
    .input-max-btn:hover { background:#00cc7a; }
    .token-selector-btn {
      background: #191d27; color:#00ffa8;border:1.3px solid #00ffa8;font-weight:700;border-radius:7px;padding:5px 10px;font-size:0.9rem;cursor:pointer;margin-bottom:6px;margin-right:3px;
      transition: background .13s;
    }
    .token-selector-btn.selected {
      background: #00ffa8; color: #191d27; border: 1.3px solid #00ffa8;
    }
    .token-selector-btn:hover:not(.selected) { background:#1e2a38; color:#fff; }
    @media (max-width:520px){
      .tokens-list {grid-template-columns:repeat(auto-fit,minmax(80px,1fr));gap:4px;}
      .fixed-button-bar {gap:2px;padding:5px 1px 4px;}
      .fixed-button-bar button{font-size:0.91rem;padding:5px 4px;min-width:36px;}
      .token-item{padding:7px 1px 5px;min-height:38px;}
      .token-symbol{font-size:0.91rem;}
    }
  </style>
</head>
<body>
  <header>
    <div id="logo-left">FIXORIUM</div>
    <div id="wallet-btn-row">
      <button id="browserWalletBtn" title="Connect / Disconnect Wallet">Browser Wallet</button>
      <button id="phantomWalletBtn" title="Connect with Phantom">Phantom</button>
    </div>
    <div id="logo-center"></div>
  </header>
  <main>
    <div id="root"></div>
  </main>
  <script type="text/javascript">
    (() => {
      const e = React.createElement;
      const { useState, useEffect, useCallback, useRef } = React;
      // Only SOL, FIXERCOIN, FARTCOIN, PNUT, RAYDIUM, PUMPFUN
      const tokensList = [
        { symbol: "SOL", name: "Solana", decimals: 9, cg: "solana", mint: null, pump: null },
        { symbol: "FIXERCOIN", name: "FixerCoin", decimals: 9, cg: "", mint: new solanaWeb3.PublicKey("D2mGkp5D43jirFeapx8UZmpiH7FaWeX1eUWy94q1F2hD"), pump: "D2mGkp5D43jirFeapx8UZmpiH7FaWeX1eUWy94q1F2hD" },
        { symbol: "FARTCOIN", name: "FartCoin", decimals: 9, cg: "", mint: new solanaWeb3.PublicKey("4nq8Q2WCmkYj6p7VtM6oQk4uQdD8A1KfB1kJ2UuLtRKmM"), pump: "4nq8Q2WCmkYj6p7VtM6oQk4uQdD8A1KfB1kJ2UuLtRKmM" },
        { symbol: "PNUT", name: "Peanut", decimals: 6, cg: "peanut", mint: new solanaWeb3.PublicKey("HWrG8q1wP7a5gHCZcdp5Ew2d3p4h2mD8Ph7Qz5fE5Uj9"), pump: "HWrG8q1wP7a5gHCZcdp5Ew2d3p4h2mD8Ph7Qz5fE5Uj9" },
        { symbol: "RAYDIUM", name: "Raydium", decimals: 6, cg: "raydium", mint: new solanaWeb3.PublicKey("4k3Dyjzvzp8e2nKk5QK8LBhEDuB7g6b8f9G8r5Xy5s52"), pump: "4k3Dyjzvzp8e2nKk5QK8LBhEDuB7g6b8f9G8r5Xy5s52" },
        { symbol: "PUMPFUN", name: "PumpFun", decimals: 9, cg: "", mint: new solanaWeb3.PublicKey("Gt4w6kWzv9mY5cQpJbYX3mLh6wC1g3LJrF3fM9W1tQzN"), pump: "Gt4w6kWzv9mY5cQpJbYX3mLh6wC1g3LJrF3fM9W1tQzN" }
      ];
      const connection = new solanaWeb3.Connection("https://solana-api.projectserum.com", "confirmed");
      const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
      const ASSOCIATED_TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("ATokenGPvR1HuTRHqpPDp7HHTRmAg3zRk6USH3UUZsM");
      const SOL_MINT = "So11111111111111111111111111111111111111112";
      const JUPITER_API_BASE = "https://quote-api.jup.ag/v6";
      function openPhantomDeeplink() {
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        if (!isMobile) {
          window.open("https://phantom.app/", "_blank");
          return;
        }
        const dlink = "https://phantom.app/ul/v1/connect?app_url="+encodeURIComponent(window.location.origin)+"&redirect_link="+encodeURIComponent(window.location.href);
        window.location.href = dlink;
      }
      async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {
        return (
          await solanaWeb3.PublicKey.findProgramAddress(
            [walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()],
            ASSOCIATED_TOKEN_PROGRAM_ID
          )
        )[0];
      }
      function toBaseUnits(amountStr, decimals) {
        try {
          const val = parseFloat(amountStr);
          if (isNaN(val) || val <= 0) return 0;
          return Math.round(val * 10 ** decimals);
        } catch {
          return 0;
        }
      }
      function useBotSignals(prices, changes) {
        return Object.fromEntries(tokensList.map(t => {
          const ch = changes && changes[t.symbol];
          if (typeof ch !== "number") return [t.symbol, ""];
          if (ch >= 2) return [t.symbol, "BUY"];
          if (ch <= -2) return [t.symbol, "SELL"];
          return [t.symbol, ""];
        }));
      }
      // Deposit modal
      function DepositModal({ publicKey, onClose }) {
        const qrCanvasRef = useRef(null);
        useEffect(() => {
          if (qrCanvasRef.current && publicKey) {
            const qrString = `solana:${publicKey.toBase58()}`;
            window.QRCode.toCanvas(qrCanvasRef.current, qrString, { width: 120 });
          }
        }, [publicKey]);
        return e(
          "div",
          { className: "overlay-bg", onClick: onClose },
          e(
            "div",
            { className: "overlay-panel", onClick: e => e.stopPropagation() },
            e("div", { className: "overlay-header" },
              e("h2", null, "Deposit"),
              e("button", { className: "overlay-close-btn", onClick: onClose }, "×")
            ),
            e("div", null,
              publicKey && e("div", { id: "depositAddress" }, publicKey.toBase58()),
              e("canvas", { ref: qrCanvasRef, id: "qrcode" }),
              e("small", null, "Send only SOL or SPL tokens to this address on Solana.")
            )
          )
        );
      }
      // Withdraw modal
      function WithdrawModal({
        tokensList, balances, publicKey, provider, connection, prices, onClose, fetchBalancesAndPrices, ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID
      }) {
        const [withdrawToken, setWithdrawToken] = useState(tokensList[0]);
        const [withdrawAmount, setWithdrawAmount] = useState("");
        const [withdrawReceiveAddress, setWithdrawReceiveAddress] = useState("");
        const [withdrawing, setWithdrawing] = useState(false);
        const [error, setError] = useState("");
        const [status, setStatus] = useState("");
        const inputRef = useRef();
        useEffect(()=>{ inputRef.current && inputRef.current.focus(); },[]);
        async function innerFindAssociatedTokenAddress(walletAddress, tokenMintAddress) {
          return (
            await solanaWeb3.PublicKey.findProgramAddress(
              [walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()],
              ASSOCIATED_TOKEN_PROGRAM_ID
            )
          )[0];
        }
        async function handleWithdrawConfirm(ev) {
          ev.preventDefault();
          setWithdrawing(true);
          setError("");
          setStatus("");
          try {
            if (!provider) throw new Error("Wallet not connected");
            if (!publicKey) throw new Error("Wallet not connected");
            if (!withdrawReceiveAddress || withdrawReceiveAddress.trim().length === 0) throw new Error("Receiver address required");
            if (!withdrawAmount || isNaN(parseFloat(withdrawAmount)) || parseFloat(withdrawAmount) <= 0) throw new Error("Invalid withdraw amount");
            const amountFloat = parseFloat(withdrawAmount);
            const decimals = withdrawToken.decimals;
            let amountBaseUnits = Math.round(amountFloat * Math.pow(10, decimals));
            if (withdrawToken.symbol === "SOL") {
              const tx = new solanaWeb3.Transaction().add(
                solanaWeb3.SystemProgram.transfer({
                  fromPubkey: publicKey,
                  toPubkey: new solanaWeb3.PublicKey(withdrawReceiveAddress),
                  lamports: amountBaseUnits,
                })
              );
              tx.feePayer = publicKey;
              tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
              const signed = await provider.signTransaction(tx);
              const signature = await connection.sendRawTransaction(signed.serialize());
              await connection.confirmTransaction(signature, "confirmed");
              setStatus("Withdraw successful. Tx: " + signature);
              onClose();
              fetchBalancesAndPrices && fetchBalancesAndPrices();
              return;
            } else {
              if (!withdrawToken.mint) throw new Error("Selected token not supported for token transfer network.");
              const fromATA = await innerFindAssociatedTokenAddress(publicKey, withdrawToken.mint);
              const toATA = await innerFindAssociatedTokenAddress(new solanaWeb3.PublicKey(withdrawReceiveAddress), withdrawToken.mint);
              const toATAInfo = await connection.getAccountInfo(toATA);
              const instructions = [];
              if (!toATAInfo) {
                instructions.push(
                  solanaWeb3.Token.createAssociatedTokenAccountInstruction(
                    ASSOCIATED_TOKEN_PROGRAM_ID,
                    TOKEN_PROGRAM_ID,
                    withdrawToken.mint,
                    toATA,
                    new solanaWeb3.PublicKey(withdrawReceiveAddress),
                    publicKey
                  )
                );
              }
              instructions.push(
                solanaWeb3.Token.createTransferInstruction(
                  TOKEN_PROGRAM_ID,
                  fromATA,
                  toATA,
                  publicKey,
                  [],
                  amountBaseUnits
                )
              );
              const tx = new solanaWeb3.Transaction().add(...instructions);
              tx.feePayer = publicKey;
              tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
              const signed = await provider.signTransaction(tx);
              const signature = await connection.sendRawTransaction(signed.serialize());
              await connection.confirmTransaction(signature, "confirmed");
              setStatus("Withdraw successful. Tx: " + signature);
              onClose();
              fetchBalancesAndPrices && fetchBalancesAndPrices();
            }
          } catch (e) {
            setError(e.message || "Withdrawal failed.");
          }
          setWithdrawing(false);
        }
        const userBal = (balances[withdrawToken.symbol] || 0).toFixed(withdrawToken.decimals);
        return e(
          "div",
          { className: "overlay-bg", onClick: onClose },
          e(
            "div",
            { className: "overlay-panel", onClick: e => e.stopPropagation() },
            e("div", { className: "overlay-header" },
              e("h2", null, "Withdraw"),
              e("button", { className: "overlay-close-btn", onClick: onClose }, "×")
            ),
            e(
              "div",
              { style: {marginBottom:10} },
              tokensList.map(t =>
                e("button", {
                  key: t.symbol,
                  type: "button",
                  className: "token-selector-btn" + (withdrawToken.symbol === t.symbol ? " selected" : ""),
                  onClick: ()=>{ setWithdrawToken(t); setWithdrawAmount(""); setError(""); }
                }, t.symbol)
              )
            ),
            e(
              "form",
              { onSubmit: handleWithdrawConfirm, noValidate: true },
              e("div", { className: "form-row" },
                e("label", { htmlFor: "withdrawAmount" }, `Amount`),
                e("div", { className: "input-max-btn-wrapper" },
                  e("input", {
                    id: "withdrawAmount",
                    ref: inputRef,
                    type: "number",
                    min: "0",
                    max: userBal,
                    step: "any",
                    required: true,
                    style: { width: 85 },
                    value: withdrawAmount,
                    placeholder: "0",
                    onChange: e => {
                      let val = e.target.value;
                      if (parseFloat(val) > parseFloat(userBal)) val = userBal;
                      setWithdrawAmount(val);
                      setError("");
                    }
                  }),
                  e("button", {
                    type: "button",
                    className: "input-max-btn",
                    onClick: () => setWithdrawAmount(userBal),
                    tabIndex: 0
                  }, "Max")
                ),
                e("span", null, withdrawToken.symbol)
              ),
              e("div", { className: "form-row" },
                e("label", { htmlFor: "withdrawReceiveAddress" }, "To"),
                e("input", {
                  id: "withdrawReceiveAddress",
                  type: "text",
                  placeholder: "Recipient address",
                  value: withdrawReceiveAddress,
                  onChange: e => setWithdrawReceiveAddress(e.target.value.trim()),
                  required: true,
                  style: { width: 120 },
                  spellCheck: false,
                  autoComplete: "off"
                })
              ),
              e("div", { style: { color: "#ffe", fontSize: "0.91rem", marginTop: 5 } },
                "Balance: ",
                userBal, " ", withdrawToken.symbol
              ),
              e("button", { className: "modal-btn", type: "submit", disabled: withdrawing || !withdrawAmount || !withdrawReceiveAddress },
                withdrawing ? e("span", { className: "dot-loader" }, e("span"), e("span"), e("span")) : "Withdraw"
              )
            ),
            error && e("div", { className: "error" }, error),
            status && e("div", { className: "status" }, status)
          )
        );
      }
      // -- SwapModal: same as before, small style (not repeated for brevity)
      // ... use same SwapModal as before, just ensure box/modal and button sizing is small.
      // -- App --
      function App() {
        const [provider,setProvider]=useState(null);
        const [walletConnected,setWalletConnected]=useState(false);
        const [publicKey,setPublicKey]=useState(null);
        const [balances,setBalances]=useState({});
        const [prices,setPrices]=useState({});
        const [pumpPrices, setPumpPrices] = useState({});
        const [loading,setLoading]=useState(false);
        const [loadingPrices,setLoadingPrices]=useState(false);
        const [activeModal,setActiveModal]=useState(null);
        const [error,setError]=useState("");
        const [status,setStatus]=useState("");
        // For swap modal only
        const [swapFromToken,setSwapFromToken]=useState(tokensList[0]);
        const [swapToToken,setSwapToToken]=useState(tokensList[1]);
        const [swapAmount,setSwapAmount]=useState("");
        const [routes,setRoutes]=useState([]);
        const [selectedRoute,setSelectedRoute]=useState(null);
        const [swapping,setSwapping]=useState(false);
        const [loadingQuotes,setLoadingQuotes]=useState(false);

        const signals = useBotSignals(prices, {});

        // Phantom detection, connect/disconnect, fetch logic
        useEffect(() => {
          function detectProvider() {
            if (window.solana && window.solana.isPhantom) {
              setProvider(window.solana);
            } else {
              setProvider(null);
            }
          }
          detectProvider();
          window.addEventListener('photon#initialized', detectProvider);
          return () => window.removeEventListener('photon#initialized', detectProvider);
        }, []);
        const connectWallet = useCallback(async () => {
          setError("");
          if (!provider) { setError("Phantom Wallet not found."); return; }
          try {
            const resp = await provider.connect();
            setPublicKey(new solanaWeb3.PublicKey(resp.publicKey.toString()));
            setWalletConnected(true); setError(""); setStatus("");
          } catch (err) { setError("Wallet connection rejected or failed."); }
        },[provider]);
        const disconnectWallet = async () => {
          if (!provider) return;
          try { await provider.disconnect(); } catch { }
          setWalletConnected(false); setPublicKey(null); setBalances({}); setPrices({}); setRoutes([]); setSelectedRoute(null); setStatus(""); setError(""); setSwapAmount(""); setActiveModal(null);
        };
        useEffect(() => {
          const btn = document.getElementById("browserWalletBtn");
          if (!btn) return;
          btn.innerText = walletConnected && publicKey ? (publicKey.toBase58().slice(0,6)+"..."+publicKey.toBase58().slice(-6)) : "Browser Wallet";
          btn.onclick = () => { if(walletConnected) disconnectWallet(); else connectWallet(); };
        }, [walletConnected,publicKey,connectWallet]);
        useEffect(() => {
          const pbtn = document.getElementById("phantomWalletBtn");
          if (pbtn) {
            pbtn.onclick = openPhantomDeeplink;
          }
        }, []);
        useEffect(() => {
          if (!provider) return;
          const onConnect = (pk) => {
            const addr = typeof pk.toBase58==="function"?pk.toBase58():pk.toString();
            setPublicKey(new solanaWeb3.PublicKey(addr));
            setWalletConnected(true); setError(""); setStatus("");
            const btn = document.getElementById("browserWalletBtn");
            if (btn) btn.innerText = addr.slice(0,6)+"..."+addr.slice(-6);
          };
          const onDisconnect = () => {
            setWalletConnected(false); setPublicKey(null); setBalances({}); setPrices({}); setRoutes([]); setSelectedRoute(null); setError(""); setStatus(""); setSwapAmount(""); setActiveModal(null);
          };
          provider.on("connect",onConnect);
          provider.on("disconnect",onDisconnect);
          if(provider.isConnected && provider.publicKey) onConnect(provider.publicKey);
          return ()=>{ provider.removeListener&&provider.removeListener("connect",onConnect); provider.removeListener&&provider.removeListener("disconnect",onDisconnect); }
        },[provider]);
        async function fetchPumpPrices() {
          try {
            const pumpEntries = await Promise.all(tokensList
              .filter(t => t.pump)
              .map(async t => {
                try {
                  const resp = await axios.get(`https://api.pump.fun/api/tokens/${t.pump}`);
                  return [t.symbol, resp.data.priceUi];
                } catch {
                  return [t.symbol, null];
                }
              })
            );
            setPumpPrices(Object.fromEntries(pumpEntries));
          } catch {
            setPumpPrices({});
          }
        }
        async function fetchPrices() {
          setLoadingPrices(true);
          try {
            const ids = tokensList.map(t=>t.cg).filter(Boolean).join(",");
            if(!ids) { setPrices({}); setLoadingPrices(false); return; }
            const url = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${ids}&price_change_percentage=24h`;
            const {data} = await axios.get(url,{headers:{Accept:"application/json"}});
            const p={};
            for(const t of tokensList){
              const obj = data.find(d => d.id===t.cg);
              p[t.symbol] = obj ? obj.current_price : null;
            }
            setPrices(p);
          } catch {
            setError("Unable to fetch token prices.");
          }
          setLoadingPrices(false);
        }
        async function fetchAll() {
          setLoading(true);
          setError("");
          try {
            await fetchPrices();
            await fetchPumpPrices();
            if (walletConnected && publicKey) {
              const solLamports = await connection.getBalance(publicKey);
              const newBalances = { SOL: solLamports / 1e9 };
              await Promise.all(tokensList.map(async t => {
                if (!t.mint) return;
                try {
                  const ata = await findAssociatedTokenAddress(publicKey, t.mint);
                  const info = await connection.getParsedAccountInfo(ata);
                  newBalances[t.symbol] = info.value?.data?.parsed?.info?.tokenAmount?.uiAmount || 0;
                } catch { newBalances[t.symbol]=0; }
              }));
              setBalances(newBalances);
            } else {
              setBalances({});
            }
          } catch (err) {
            setError("Error loading balances or prices.");
          }
          setLoading(false);
        }
        useEffect(() => { fetchAll(); const intv1 = setInterval(fetchPrices,60000); const intv2 = setInterval(fetchPumpPrices,60000); return ()=>{clearInterval(intv1);clearInterval(intv2);}; }, []);
        useEffect(() => { fetchAll(); }, [walletConnected,publicKey,activeModal,status]);
        useEffect(() => { fetchPumpPrices(); }, []);
        // For swap modal, you can use the same as previous, or keep it minimal.
        // For brevity, not repeating swap modal here.
        // Main UI
        return e(
          React.Fragment,
          null,
          error && e("div", { className: "error", role: "alert" }, error),
          status && e("div", { className: "status", role: "status" }, status),
          e(
            "div",
            { id: "totalBalance", "aria-live": "polite", "aria-atomic": "true" },
            loading
              ? e("span", null, "Loading… ", e("span", { className: "dot-loader" }, e("span"), e("span"), e("span")))
              : "$" + tokensList.reduce((sum, t) => {
                  const bal = balances[t.symbol] || 0;
                  const price = prices[t.symbol] || pumpPrices[t.symbol] || 0;
                  return sum + bal * price;
                }, 0).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })
          ),
          e(
            "div",
            { className: "tokens-list", "aria-label": "Tokens list" },
            tokensList.map(token =>
              e(
                "div",
                { key: token.symbol, className: "token-item", tabIndex: 0 },
                e("div", { className: "token-symbol" }, token.name),
                e("div", { className: "token-balance" },
                  loading && walletConnected
                    ? e("span", { className: "dot-loader" }, e("span"), e("span"), e("span"))
                    : walletConnected
                      ? (balances[token.symbol] || 0).toLocaleString(undefined, { maximumFractionDigits: token.decimals })
                      : "0"
                ),
                e("div", { className: "token-price" },
                  loadingPrices
                    ? e("span", { className: "dot-loader" }, e("span"), e("span"), e("span"))
                    : (prices[token.symbol] != null
                      ? "$" + prices[token.symbol].toLocaleString(undefined, { maximumFractionDigits: 6 })
                      : (pumpPrices[token.symbol] != null
                        ? e("span", { style:{color:"#ffdf00",fontWeight:600} }, "Pump: $"+Number(pumpPrices[token.symbol]).toPrecision(6))
                        : "N/A"
                      )
                    ),
                  signals[token.symbol] === "BUY" &&
                    e("button", { className: "buy-btn blink", tabIndex: -1 }, "BUY"),
                  signals[token.symbol] === "SELL" &&
                    e("button", { className: "sell-btn blink", tabIndex: -1 }, "SELL")
                )
              )
            )
          ),
          // Fixed bottom button bar (always)
          e(
            "div",
            { className: "fixed-button-bar" },
            e("button", { onClick: () => setActiveModal("swap") }, "Swap"),
            e("button", { onClick: () => setActiveModal("withdraw") }, "Withdraw"),
            e("button", { onClick: () => setActiveModal("deposit") }, "Deposit")
          ),
          // Deposit modal
          activeModal === "deposit" && e(DepositModal, {
            publicKey, onClose: () => setActiveModal(null)
          }),
          // Withdraw modal
          activeModal === "withdraw" && e(WithdrawModal, {
            tokensList, balances, publicKey, provider, connection, prices,
            onClose: () => setActiveModal(null),
            fetchBalancesAndPrices: fetchAll,
            ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID
          })
          // You can add a minimal swap modal or import previous one.
        );
      }
      ReactDOM.render(e(App), document.getElementById("root"));
    })();
  </script>
</body>
</html>

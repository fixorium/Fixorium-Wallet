 <!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FIXORIUM Wallet - SOL Network Deposit, Withdraw & Swap</title>

  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Axios -->
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <!-- Solana web3.js -->
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.2/lib/index.iife.min.js"></script>
  <!-- BN.js for big number -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bn.js/5.2.0/bn.min.js" crossorigin="anonymous"></script>

  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      max-width: 580px;
      margin: 20px auto 90px;
      font-size: 12px;
      background: #121212;
      color: #eee;
      padding: 0 15px 0 15px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      user-select: none;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    h1 {
      font-weight: 900;
      text-align: center;
      margin-bottom: 14px;
      font-size: 2rem;
      color: #1e90ff;
      user-select: text;
    }

    button {
      cursor: pointer;
      background-color: #1e90ff;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 16px;
      font-size: 1rem;
      font-weight: 700;
      transition: background-color 0.3s ease;
      user-select: none;
      min-width: 100px;
      margin: 4px 4px 4px 0;
    }

    button:hover:not([disabled]) {
      background-color: #0050aa;
    }

    button[disabled] {
      background-color: #555555;
      cursor: not-allowed;
    }

    fieldset {
      border: 1px solid #333;
      border-radius: 12px;
      padding: 16px 20px;
      background: #222;
      box-shadow: 0 0 10px #1e90ff66;
    }

    legend {
      font-weight: 900;
      font-size: 1.15rem;
      color: #1e90ff;
      padding: 0 10px;
      user-select: none;
    }

    label {
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 6px;
      display: block;
      user-select: text;
      color: #ccc;
    }

    input[type="number"],
    input[type="text"],
    select {
      width: 100%;
      padding: 8px 10px;
      font-size: 0.9rem;
      border: 1.5px solid #444;
      border-radius: 8px;
      margin-top: 6px;
      margin-bottom: 10px;
      box-sizing: border-box;
      background-color: #121212;
      color: #eee;
      transition: border-color 0.25s ease;
      user-select: text;
    }

    input[type="number"]:focus,
    input[type="text"]:focus,
    select:focus {
      outline: none;
      border-color: #1e90ff;
      box-shadow: 0 0 8px #1e90ff80;
    }

    .balances-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-weight: 600;
      font-size: 1rem;
      user-select: none;
      margin-bottom: 8px;
      justify-content: center;
    }

    .balance-item {
      background-color: #1e2a38;
      border-radius: 14px;
      padding: 8px 14px;
      min-width: 160px;
      text-align: center;
      display: flex;
      gap: 10px;
      align-items: center;
      user-select: text;
      color: #eee;
    }

    .token-logo {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      user-select: none;
      object-fit: contain;
    }

    .token-symbol {
      font-weight: 700;
      font-size: 1.1rem;
      user-select: text;
    }

    .token-details {
      flex-grow: 1;
      text-align: left;
      user-select: text;
    }

    .error {
      color: #ff4d4f;
      font-weight: 700;
      margin-top: 0;
      margin-bottom: 0;
      user-select: text;
      text-align: center;
    }

    .status {
      color: #1e90ff;
      font-weight: 700;
      user-select: text;
      margin-top: 6px;
      margin-bottom: 0;
      min-height: 1.5em;
      text-align: center;
    }

    footer {
      font-size: 0.75rem;
      color: #888;
      text-align: center;
      user-select: none;
      margin-top: auto;
      margin-bottom: 20px;
      padding-top: 10px;
      border-top: 1px solid #333;
    }

    a {
      color: #4ca3ff;
      text-decoration: underline;
      user-select: text;
    }

    .button-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 10px;
    }

    .textarea-address {
      width: 100%;
      padding: 6px 10px;
      font-size: 0.9rem;
      height: 50px;
      resize: none;
      border-radius: 8px;
      border: 1.5px solid #444;
      background-color: #121212;
      color: white;
      margin-bottom: 12px;
      font-family: monospace;
    }

    .ad-banner {
      background-color: #1e90ff;
      border-radius: 12px;
      padding: 12px 15px;
      text-align: center;
      color: white;
      user-select: none;
      font-weight: 700;
      font-size: 1.1rem;
      box-shadow: 0 0 10px #1e90ffbb;
    }

    @media (max-width: 460px) {
      .balance-item {
        min-width: 100%;
        font-size: 0.95rem;
      }
      button {
        min-width: 100%;
      }
    }
  </style>
</head>

<body>
  <h1>FIXORIUM Wallet</h1>
  <div id="root"></div>

  <div class="ad-banner" id="ad-banner">
    -- Advertisement: Engage in secure Solana trading with FIXORIUM --
  </div>

  <script type="text/javascript">
    (() => {
      const e = React.createElement;
      const { useState, useEffect, useCallback } = React;
      const {
        Connection,
        PublicKey,
        Transaction,
        SystemProgram,
        TransactionInstruction,
        SYSVAR_RENT_PUBKEY,
      } = solanaWeb3;
      const BN = window.BN;

      // RPC & API
      const connection = new Connection("https://solana-api.projectserum.com", "confirmed");
      const JUPITER_API_BASE = "https://quote-api.jup.ag/v6";
      const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
      const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvR1HuTRHqpPDp7HHTRmAg3zRk6USH3UUZsM");
      const SOL_MINT = "So11111111111111111111111111111111111111112";

      // Tokens list - add or remove manually here:
      const tokensList = [
        { mint: null, symbol: "SOL", name: "Solana", decimals: 9, logoURI: "https://cryptologos.cc/logos/solana-sol-logo.svg?v=014" },
        { mint: new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"), symbol: "USDC", name: "USD Coin", decimals: 6, logoURI: "https://cryptologos.cc/logos/usd-coin-usdc-logo.svg?v=014" },
        { mint: new PublicKey("Es9vMFrzaCER7N1TvjVqauDziYbPEmxW5M9VpX1TTd8C"), symbol: "USDT", name: "Tether USD", decimals: 6, logoURI: "https://cryptologos.cc/logos/tether-usdt-logo.svg?v=014" },
        { mint: new PublicKey("D2mGkp5D43jirFeapx8UZmpiH7FaWeX1eUWy94q1F2hD"), symbol: "FIXR", name: "FixerCoin", decimals: 9, logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/solana/assets/D2mGkp5D43jirFeapx8UZmpiH7FaWeX1eUWy94q1F2hD/logo.png" },
      ];

      async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {
        return (
          await PublicKey.findProgramAddress([walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()], ASSOCIATED_TOKEN_PROGRAM_ID)
        )[0];
      }

      function toBaseUnits(amountStr, decimals) {
        try {
          const val = parseFloat(amountStr);
          if (isNaN(val) || val <= 0) return 0;
          return Math.round(val * 10 ** decimals);
        } catch {
          return 0;
        }
      }

      function TokenLogo({ token }) {
        if (token.logoURI)
          return e("img", { src: token.logoURI, alt: token.symbol, className: "token-logo" });
        return e("div", { className: "token-logo", style: { backgroundColor: "#444", fontWeight: "bold", fontSize: 14, textAlign: "center", lineHeight: "28px", borderRadius: 6, userSelect: "none" }, title: token.name }, token.symbol);
      }

      function App() {
        // Wallet
        const [provider, setProvider] = useState(null);
        const [walletConnected, setWalletConnected] = useState(false);
        const [publicKey, setPublicKey] = useState(null);
        // Balances + Prices
        const [balances, setBalances] = useState({});
        const [prices, setPrices] = useState({}); // symbol => USD price
        // Form states
        const [withdrawAddress, setWithdrawAddress] = useState("");
        const [withdrawAmount, setWithdrawAmount] = useState("");
        const [splWithdrawTokenSymbol, setSplWithdrawTokenSymbol] = useState("FIXR");
        const [splWithdrawAddress, setSplWithdrawAddress] = useState("");
        const [splWithdrawAmount, setSplWithdrawAmount] = useState("");
        const [swapAmount, setSwapAmount] = useState("");
        const [slippage, setSlippage] = useState("0.5");
        // Swap is only SOL <> FIXR
        const fixrToken = tokensList.find(t => t.symbol === "FIXR");
        const fromToken = tokensList[0]; // SOL fixed buy/sell
        const toToken = fixrToken;
        // Swap routes & status
        const [routes, setRoutes] = useState([]);
        const [selectedRoute, setSelectedRoute] = useState(null);
        const [loadingQuotes, setLoadingQuotes] = useState(false);
        const [swapping, setSwapping] = useState(false);
        const [withdrawing, setWithdrawing] = useState(false);
        // Messages
        const [error, setError] = useState("");
        const [status, setStatus] = useState("");

        // Detect Phantom
        useEffect(() => {
          const p = (() => {
            if (window.solana && window.solana.isPhantom) return window.solana;
            if (window.phantom && window.phantom.solana && window.phantom.solana.isPhantom)
              return window.phantom.solana;
            return null;
          })();
          setProvider(p);
        }, []);

        // Connect wallet
        const connectWallet = useCallback(async () => {
          setError("");
          if (!provider) {
            setError("Phantom Wallet not found. Please install Phantom.");
            return;
          }
          try {
            const resp = await provider.connect();
            setPublicKey(new PublicKey(resp.publicKey.toString()));
            setWalletConnected(true);
            setError("");
            setStatus("");
          } catch {
            setError("Wallet connection rejected or failed.");
          }
        }, [provider]);

        const disconnectWallet = async () => {
          if (!provider) return;
          try { await provider.disconnect(); } catch { }
          setWalletConnected(false);
          setPublicKey(null);
          setBalances({});
          setPrices({});
          setRoutes([]);
          setSelectedRoute(null);
          setStatus("");
          setError("");
          setSwapAmount("");
          setWithdrawAmount("");
          setWithdrawAddress("");
          setSplWithdrawAmount("");
          setSplWithdrawAddress("");
        };

        useEffect(() => {
          if (!provider) return;
          const onConnect = (pk) => {
            setPublicKey(new PublicKey(pk.toString()));
            setWalletConnected(true);
            setError("");
            setStatus("");
          };
          const onDisconnect = () => {
            setWalletConnected(false);
            setPublicKey(null);
            setBalances({});
            setPrices({});
            setRoutes([]);
            setSelectedRoute(null);
            setError("");
            setStatus("");
            setSwapAmount("");
            setWithdrawAmount("");
            setWithdrawAddress("");
            setSplWithdrawAmount("");
            setSplWithdrawAddress("");
          };
          provider.on("connect", onConnect);
          provider.on("disconnect", onDisconnect);
          if (provider.isConnected) onConnect(provider.publicKey);
          return () => {
            provider.removeListener && provider.removeListener("connect", onConnect);
            provider.removeListener && provider.removeListener("disconnect", onDisconnect);
          };
        }, [provider]);

        // Refresh balances and prices
        useEffect(() => {
          if (!walletConnected || !publicKey) {
            setBalances({});
            setPrices({});
            return;
          }
          async function fetch() {
            setError("");
            try {
              const solLamports = await connection.getBalance(publicKey);
              const newBalances = { SOL: solLamports / 1e9 };
              await Promise.all(tokensList.map(async (t) => {
                if (!t.mint) return;
                try {
                  const ata = await findAssociatedTokenAddress(publicKey, t.mint);
                  const info = await connection.getParsedAccountInfo(ata);
                  newBalances[t.symbol] = info.value?.data?.parsed?.info?.tokenAmount?.uiAmount || 0;
                } catch {
                  newBalances[t.symbol] = 0;
                }
              }));
              setBalances(newBalances);

              // Fetch prices from CoinGecko (solana and selected tokens)
              // Map tokens to CoinGecko IDs:
              const cgMap = {
                SOL: "solana",
                USDC: "usd-coin",
                USDT: "tether",
                FIXR: "ethereum", // Placeholder, replace with real FIXR ID on CG or your own oracle or 0 price
              };
              const ids = Object.values(cgMap).filter(Boolean).join(",");
              const cgResp = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd`);
              const pricesObj = {};
              Object.entries(cgMap).forEach(([symbol, id]) => {
                pricesObj[symbol] = cgResp.data[id]?.usd || 0;
              });
              setPrices(pricesObj);
            } catch (e) {
              setError("Error loading balances or prices.");
            }
          }
          fetch();
        }, [walletConnected, publicKey]);

        // Deposit: Instruction only (send tokens to address)
        const depositTokensInstructions = () => {
          if (!publicKey) return "";
          return publicKey.toBase58();
        };

        // Withdraw SOL
        async function withdrawSol() {
          setError("");
          setStatus("");
          if (!walletConnected || !publicKey || !provider) {
            setError("Wallet not connected.");
            return;
          }
          if (!withdrawAmount || isNaN(parseFloat(withdrawAmount)) || parseFloat(withdrawAmount) <= 0) {
            setError("Enter valid withdraw amount.");
            return;
          }
          let amountVal = parseFloat(withdrawAmount);
          if (amountVal > (balances.SOL || 0)) {
            setError("Withdraw amount exceeds SOL balance.");
            return;
          }
          let dest;
          try {
            dest = new PublicKey(withdrawAddress);
          } catch {
            setError("Invalid recipient address.");
            return;
          }
          setWithdrawing(true);
          try {
            const tx = new Transaction().add(
              SystemProgram.transfer({
                fromPubkey: publicKey,
                toPubkey: dest,
                lamports: Math.round(amountVal * 1e9),
              }));
            tx.feePayer = publicKey;
            const latestBlockhash = (await connection.getLatestBlockhash()).blockhash;
            tx.recentBlockhash = latestBlockhash;
            const signed = await provider.signTransaction(tx);
            const txid = await connection.sendRawTransaction(signed.serialize());
            setStatus(`Withdraw SOL tx sent: ${txid}`);
            await connection.confirmTransaction(txid);
            setStatus(`Withdraw SOL tx confirmed: ${txid}`);
            setWithdrawAmount("");
            setWithdrawAddress("");
            // Refresh balances
            const lamports = await connection.getBalance(publicKey);
            setBalances(b => ({ ...b, SOL: lamports / 1e9 }));
          } catch (e) {
            setError("Withdraw SOL failed: " + (e.message || e.toString()));
          }
          setWithdrawing(false);
        }

        // Withdraw SPL Token
        async function withdrawSPLToken() {
          setError("");
          setStatus("");
          if (!walletConnected || !publicKey || !provider) {
            setError("Wallet not connected.");
            return;
          }
          if (!splWithdrawAmount || isNaN(parseFloat(splWithdrawAmount)) || parseFloat(splWithdrawAmount) <= 0) {
            setError("Enter valid token withdraw amount.");
            return;
          }
          if (!splWithdrawAddress) {
            setError("Enter recipient address.");
            return;
          }
          let recipient;
          try {
            recipient = new PublicKey(splWithdrawAddress);
          } catch {
            setError("Invalid recipient address.");
            return;
          }
          const amount = parseFloat(splWithdrawAmount);
          const tokenData = tokensList.find(t => t.symbol === splWithdrawTokenSymbol);
          if (!tokenData || !tokenData.mint) {
            setError("Invalid token selected.");
            return;
          }
          if ((balances[tokenData.symbol] || 0) < amount) {
            setError(`Insufficient ${tokenData.symbol} balance.`);
            return;
          }
          setWithdrawing(true);
          try {
            const senderATA = await findAssociatedTokenAddress(publicKey, tokenData.mint);
            const recipientATA = await findAssociatedTokenAddress(recipient, tokenData.mint);
            const recipientInfo = await connection.getAccountInfo(recipientATA);
            const instructions = [];
            if (!recipientInfo) {
              // Create associated token account for recipient if missing
              instructions.push(
                new TransactionInstruction({
                  keys: [
                    { pubkey: publicKey, isSigner: true, isWritable: true },
                    { pubkey: recipientATA, isSigner: false, isWritable: true },
                    { pubkey: recipient, isSigner: false, isWritable: false },
                    { pubkey: tokenData.mint, isSigner: false, isWritable: false },
                    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
                    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
                  ],
                  programId: ASSOCIATED_TOKEN_PROGRAM_ID,
                  data: Buffer.from([]),
                })
              );
            }
            // Transfer instruction
            const rawAmount = new BN(Math.round(amount * 10 ** tokenData.decimals));
            const data = Buffer.alloc(9);
            data.writeUInt8(3, 0);
            rawAmount.toArrayLike(Buffer, "le", 8).copy(data, 1);
            instructions.push(
              new TransactionInstruction({
                keys: [
                  { pubkey: senderATA, isSigner: false, isWritable: true },
                  { pubkey: recipientATA, isSigner: false, isWritable: true },
                  { pubkey: publicKey, isSigner: true, isWritable: false },
                ],
                programId: TOKEN_PROGRAM_ID,
                data,
              })
            );

            const tx = new Transaction().add(...instructions);
            tx.feePayer = publicKey;
            const blockhash = (await connection.getLatestBlockhash()).blockhash;
            tx.recentBlockhash = blockhash;
            const signed = await provider.signTransaction(tx);
            const txid = await connection.sendRawTransaction(signed.serialize());
            setStatus(`SPL Token withdraw tx sent: ${txid}`);
            await connection.confirmTransaction(txid);
            setStatus(`SPL Token withdraw tx confirmed: ${txid}`);
            // Refresh balances
            setBalances(b => ({ ...b, [tokenData.symbol]: b[tokenData.symbol] - amount }));
            setSplWithdrawAmount("");
            setSplWithdrawAddress("");
          } catch (e) {
            setError("Withdraw SPL token failed: " + (e.message || e.toString()));
          }
          setWithdrawing(false);
        }

        // Swap: only SOL <> FIXR buy/sell
        const getSwapQuotes = async () => {
          if (!walletConnected || !publicKey || !provider) {
            setError("Wallet not connected.");
            return;
          }
          if (!swapAmount || isNaN(Number(swapAmount)) || Number(swapAmount) <= 0) {
            setError("Enter valid swap amount.");
            return;
          }
          setError("");
          setStatus("");
          setRoutes([]);
          setSelectedRoute(null);
          setLoadingQuotes(true);
          try {
            const inputMint = SOL_MINT;
            const outputMint = fixrToken.mint.toBase58();
            const amountInBaseUnits = toBaseUnits(swapAmount, fromToken.decimals);
            if (amountInBaseUnits === 0) {
              setError("Amount too small.");
              setLoadingQuotes(false);
              return;
            }
            const res = await axios.get(`${JUPITER_API_BASE}/quote`, {
              params: {
                inputMint,
                outputMint,
                amount: amountInBaseUnits,
                slippageBps: Math.round(parseFloat(slippage) * 100),
                swapMode: "ExactIn",
              }, timeout: 15000,
            });
            if (res.data && Array.isArray(res.data.data) && res.data.data.length > 0) {
              setRoutes(res.data.data);
              setSelectedRoute(res.data.data[0]);
            } else {
              setError("No swap routes found.");
            }
          } catch {
            setError("Failed to fetch swap quotes.");
          }
          setLoadingQuotes(false);
        };

        const executeSwap = async () => {
          if (!selectedRoute || !walletConnected || !publicKey || !provider) {
            setError("Wallet not connected or route not selected.");
            return;
          }
          setError("");
          setStatus("");
          setSwapping(true);
          try {
            const resp = await axios.post(`${JUPITER_API_BASE}/swap`, {
              route: selectedRoute,
              userPublicKey: publicKey.toBase58(),
            }, { timeout: 15000 });
            if (!resp.data || !resp.data.swapTransactions) {
              setError("Failed to get swap transactions.");
              setSwapping(false);
              return;
            }
            if (resp.data.swapTransactions.setupTransaction) {
              const setupTx = Transaction.from(Buffer.from(resp.data.swapTransactions.setupTransaction, "base64"));
              setupTx.feePayer = publicKey;
              const blockhash = (await connection.getLatestBlockhash()).blockhash;
              setupTx.recentBlockhash = blockhash;
              const signedSetup = await provider.signTransaction(setupTx);
              const setupTxid = await connection.sendRawTransaction(signedSetup.serialize());
              setStatus("Setup tx sent: " + setupTxid);
              await connection.confirmTransaction(setupTxid);
            }
            const swapTx = Transaction.from(Buffer.from(resp.data.swapTransactions.swapTransaction, "base64"));
            swapTx.feePayer = publicKey;
            const blockhash2 = (await connection.getLatestBlockhash()).blockhash;
            swapTx.recentBlockhash = blockhash2;
            const signedSwap = await provider.signTransaction(swapTx);
            const swapTxid = await connection.sendRawTransaction(signedSwap.serialize());
            setStatus("Swap tx sent: " + swapTxid);
            await connection.confirmTransaction(swapTxid);
            setStatus("Swap confirmed: " + swapTxid);
            // Refresh balances
            const solBalanceLamports = await connection.getBalance(publicKey);
            const newBalances = { SOL: solBalanceLamports / 1e9 };
            for (const t of tokensList) {
              if (!t.mint) continue;
              try {
                const ata = await findAssociatedTokenAddress(publicKey, t.mint);
                const info = await connection.getParsedAccountInfo(ata);
                newBalances[t.symbol] = info.value?.data?.parsed?.info?.tokenAmount?.uiAmount || 0;
              } catch {
                newBalances[t.symbol] = 0;
              }
            }
            setBalances(newBalances);
            setSwapAmount("");
            setRoutes([]);
            setSelectedRoute(null);
            setError("");
          } catch (e) {
            setError("Swap failed: " + (e.message || e.toString()));
          }
          setSwapping(false);
        };

        // Total balance display in USD
        const totalBalanceUSD = Object.keys(balances).reduce((acc, symbol) => {
          const p = prices[symbol] || 0;
          const b = balances[symbol] || 0;
          return acc + (p * b);
        }, 0);

        return e("div", null,

          !walletConnected && e("button", {
            onClick: connectWallet,
            style: { width: "100%", padding: 14, fontSize: "1.1rem" },
            type: "button",
            "aria-label": "Connect Phantom Wallet"
          }, "Connect Phantom Wallet"),

          walletConnected && e(React.Fragment, null,
            e("p", { style: { userSelect: "text", fontWeight: 600, wordBreak: "break-word", textAlign: "center" } },
              `Connected wallet: ${publicKey.toBase58()}`),

            e("button", { onClick: disconnectWallet, style: { width: "100%", padding: 12, marginBottom: 12 }, type: "button" },
              "Disconnect Wallet"),

            e("div", { className: "balances-row" },
              e("div", { className: "balance-item" },
                e("span", {style:{fontWeight:"700", fontSize:"1rem"}}, "Total Balance-US$"),
                e("span", {style:{flexGrow:"1"}}), // spacer
                `$${totalBalanceUSD.toFixed(2)}`
              )
            ),

            e("fieldset", null,
              e("legend", null, "Your tokens"),
              tokensList.map(t => {
                const balance = balances[t.symbol] || 0;
                const price = prices[t.symbol] || 0;
                return e("div", { key: t.symbol, className: "balance-item", title: t.name },
                  e(TokenLogo, { token: t }),
                  e("div", { className: "token-details" },
                    e("div", { className: "token-symbol" }, t.symbol),
                    e("div", null, `Balance: ${balance.toFixed(t.decimals)}`),
                    e("div", null, `Price: $${price.toFixed(4)}`)
                  )
                );
              })
            ),

            e("div", { className: "button-row" },
              e("button", { onClick: () => alert(`Send SOL or SPL tokens to your wallet address:\n${depositTokensInstructions()}`), type: "button" }, "Deposit"),
              e("button", { type: "button", onClick: () => {
                scrollToWithdraw();
              } }, "Withdraw"),
              e("button", { type: "button", onClick: () => {
                scrollToSwap();
              } }, "Swap")
            ),

            // Withdraw Section
            e("section", { id: "withdraw-section" },
              e("fieldset", null,
                e("legend", null, "Withdraw SOL"),
                e("label", { htmlFor: "withdrawAddress" }, "Recipient Address (SOL network only)"),
                e("input", { id: "withdrawAddress", type: "text", value: withdrawAddress, onChange: ev => setWithdrawAddress(ev.target.value), placeholder: "Recipient Solana address" }),
                e("label", { htmlFor: "withdrawAmount" }, "Amount SOL"),
                e("input", { id: "withdrawAmount", type: "number", value: withdrawAmount, onChange: ev => setWithdrawAmount(ev.target.value), min: "0", step: "any", placeholder: "0" }),
                e("button", { type: "button", onClick: withdrawSol, disabled: withdrawing || !withdrawAddress || !withdrawAmount }, withdrawing ? "Withdrawing..." : "Withdraw SOL")
              ),

              e("fieldset", null,
                e("legend", null, "Withdraw SPL Token"),
                e("label", { htmlFor: "splWithdrawTokenSymbol" }, "Token"),
                e("select", { id: "splWithdrawTokenSymbol", value: splWithdrawTokenSymbol, onChange: ev => setSplWithdrawTokenSymbol(ev.target.value) },
                  tokensList.filter(t => t.symbol !== "SOL").map(t => e("option", { key: t.symbol, value: t.symbol }, t.symbol))
                ),
                e("label", { htmlFor: "splWithdrawAddress" }, "Recipient Address (SOL network only)"),
                e("input", { id: "splWithdrawAddress", type: "text", value: splWithdrawAddress, onChange: ev => setSplWithdrawAddress(ev.target.value), placeholder: "Recipient Solana address" }),
                e("label", { htmlFor: "splWithdrawAmount" }, `Amount (${splWithdrawTokenSymbol})`),
                e("input", { id: "splWithdrawAmount", type: "number", value: splWithdrawAmount, onChange: ev => setSplWithdrawAmount(ev.target.value), min: "0", step: "any", placeholder: "0" }),
                e("button", { type: "button", onClick: withdrawSPLToken, disabled: withdrawing || !splWithdrawAddress || !splWithdrawAmount }, withdrawing ? "Withdrawing..." : `Withdraw ${splWithdrawTokenSymbol}`)
              )
            ),

            // Swap Section
            e("section", { id: "swap-section" },
              e("fieldset", null,
                e("legend", null, "Swap SOL ⇄ FIXR"),
                e("label", { htmlFor: "swapAmount" }, `Amount (SOL)`),
                e("input", { id: "swapAmount", type: "number", min: "0", step: "any", value: swapAmount, onChange: ev => setSwapAmount(ev.target.value), placeholder: "0" }),
                e("label", { htmlFor: "slippage" }, "Slippage tolerance (%)"),
                e("input", { id: "slippage", type: "number", min: "0", max: "10", step: "0.1", value: slippage, onChange: ev => setSlippage(ev.target.value), placeholder: "0.5" }),
                e("button", { type: "button", onClick: getSwapQuotes, disabled: loadingQuotes || swapping || !swapAmount || parseFloat(swapAmount) <= 0 }, loadingQuotes ? "Loading quotes..." : "Get Swap Quotes"),
                routes.length > 0 && e("fieldset", { style: { marginTop: '12px' } },
                  routes.map(route => {
                    const outAmount = (parseInt(route.outAmount) / 10 ** toToken.decimals).toFixed(6);
                    const priceImpactPct = (route.priceImpactPct * 100).toFixed(3);
                    const selected = selectedRoute && selectedRoute.id === route.id;
                    return e("div", {
                      key: route.id,
                      className: "route-box" + (selected ? " selected" : ""),
                      onClick: () => setSelectedRoute(route),
                      tabIndex: 0,
                      role: "button",
                      "aria-pressed": selected,
                      style: { marginBottom: 12 }
                    }, e("div", null, e("b", null, "Expected Out: "), outAmount + " FIXR"), e("div", null, e("b", null, "Price Impact: "), priceImpactPct + "%"));
                  }),
                  e("button", { type: "button", disabled: swapping || !selectedRoute, onClick: executeSwap }, swapping ? "Swapping..." : `Swap SOL → FIXR`)
                )
              )
            ),

            e("p", { className: "status" }, status),
            e("p", { className: "error" }, error),

            e("footer", null,
              "Powered by ",
              e("a", { href: "https://solana.com", target: "_blank", rel: "noopener noreferrer" }, "Solana"), ", ",
              e("a", { href: "https://phantom.app", target: "_blank", rel: "noopener noreferrer" }, "Phantom"), " & ",
              e("a", { href: "https://jup.ag", target: "_blank", rel: "noopener noreferrer" }, "Jupiter")
            )
          )
        );

        // Smooth scroll helpers
        function scrollToWithdraw() {
          const el = document.getElementById("withdraw-section");
          if (el) el.scrollIntoView({ behavior: "smooth", block: "start" });
        }
        function scrollToSwap() {
          const el = document.getElementById("swap-section");
          if (el) el.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      }

      ReactDOM.createRoot(document.getElementById('root')).render(e(App));
    })();
  </script>
</body>

</html>

 <!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FIXORIUM - Solana SPL Token Swap</title>

  <!-- React & ReactDOM CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Axios CDN -->
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

  <!-- Solana web3 CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.75.0/lib/index.iife.min.js"></script>

  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      max-width: 480px;
      margin: 20px auto 80px;
      font-size: 14px;
      background: #f9f9f9;
      color: #222;
      padding: 0 15px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      user-select: none;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    h1 {
      font-weight: 900;
      text-align: center;
      margin-bottom: 10px;
      font-size: 2.25rem;
      color: #007aff;
      user-select: text;
    }

    button {
      cursor: pointer;
      background-color: #007aff;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 10px 18px;
      font-size: 1rem;
      transition: background-color 0.3s ease;
      user-select: none;
      font-weight: 700;
    }

    button:hover:not([disabled]) {
      background-color: #005ecb;
    }

    button[disabled] {
      background-color: #a0a0a0;
      cursor: not-allowed;
    }

    fieldset {
      border: 1px solid #ccc;
      border-radius: 12px;
      padding: 20px;
      margin-top: 20px;
      background: white;
      box-shadow: 0 1px 6px rgb(0 122 255 / 0.15);
      user-select: none;
    }

    legend {
      font-weight: 900;
      font-size: 1.2rem;
      padding: 0 10px;
      color: #007aff;
    }

    label {
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 6px;
      display: block;
      user-select: text;
    }

    select,
    input[type=number],
    input[type=text] {
      width: 100%;
      padding: 10px 12px;
      font-size: 1rem;
      border: 1.5px solid #bbb;
      border-radius: 8px;
      box-sizing: border-box;
      margin-top: 6px;
      margin-bottom: 12px;
      transition: border-color 0.25s ease;
      user-select: text;
    }

    select:focus,
    input[type=number]:focus,
    input[type=text]:focus {
      outline: none;
      border-color: #007aff;
      box-shadow: 0 0 8px #007aff80;
    }

    small {
      color: #555;
      display: block;
      margin-top: -10px;
      margin-bottom: 12px;
      font-size: 0.8rem;
      user-select: text;
      word-break: break-word;
    }

    .btn-swap {
      margin: 20px auto 0;
      display: block;
      font-weight: 700;
      font-size: 1.15rem;
      user-select: none;
      width: 100%;
    }

    .route-box {
      border: 1.5px solid #bbb;
      border-radius: 10px;
      padding: 14px 18px;
      margin-bottom: 12px;
      cursor: pointer;
      font-size: 1rem;
      background: white;
      transition: border-color 0.25s ease, background-color 0.3s ease;
      user-select: none;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .route-box:hover {
      border-color: #007aff;
      background-color: #e6f2ff;
    }

    .route-box.selected {
      border-color: #005ecb;
      background-color: #d0e4ff;
      font-weight: 700;
    }

    .token-logo {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      margin-right: 10px;
      user-select: none;
      flex-shrink: 0;
      object-fit: contain;
    }

    .token-symbol-name {
      flex-grow: 1;
      user-select: text;
      font-weight: 700;
      font-size: 1.1rem;
    }

    .route-row {
      display: flex;
      align-items: center;
    }

    p.status {
      margin-top: 20px;
      word-wrap: break-word;
      font-size: 0.9rem;
      color: #005ecb;
      font-weight: 600;
      user-select: text;
      white-space: pre-wrap;
      min-height: 2rem;
    }

    p.error {
      margin-top: 12px;
      word-wrap: break-word;
      font-size: 0.9rem;
      color: #c00;
      font-weight: 600;
      user-select: text;
      white-space: pre-wrap;
      min-height: 2rem;
    }

    .balance-info {
      font-size: 0.8rem;
      color: #666;
      margin-top: -8px;
      margin-bottom: 12px;
      user-select: none;
      font-weight: 600;
    }

    footer {
      margin-top: auto;
      font-size: 0.75rem;
      color: #666;
      text-align: center;
      user-select: none;
      padding-bottom: 20px;
    }

    a {
      color: #007aff;
      text-decoration: underline;
      user-select: text;
    }
  </style>
</head>

<body>
  <h1>FIXORIUM</h1>
  <div id="root"></div>

  <script>
    const e = React.createElement;
    const { useState, useEffect, useCallback } = React;
    const { Connection, clusterApiUrl, PublicKey, Transaction } = solanaWeb3;

    const SOL_MINT = "So11111111111111111111111111111111111111112";
    const JUPITER_API_BASE = "https://quote-api.jup.ag/v4";

    // Use reliable RPC (Project Serum) to reduce failures and better performance
    const connection = new Connection("https://solana-api.projectserum.com", "confirmed");

    // Trending SPL tokens + SOL
    const tokensList = [
      {
        address: SOL_MINT,
        symbol: "SOL",
        name: "Solana",
        decimals: 9,
        logoURI:
          "https://cryptologos.cc/logos/solana-sol-logo.svg?v=014",
      },
      {
        address: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
        symbol: "USDC",
        name: "USD Coin",
        decimals: 6,
        logoURI:
          "https://cryptologos.cc/logos/usd-coin-usdc-logo.svg?v=014",
      },
      {
        address: "Es9vMFrzaCER7N1TvjVqauDziYbPEmxW5M9VpX1TTd8C",
        symbol: "USDT",
        name: "Tether USD",
        decimals: 6,
        logoURI:
          "https://cryptologos.cc/logos/tether-usdt-logo.svg?v=014",
      },
      {
        address: "SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt",
        symbol: "SRM",
        name: "Serum",
        decimals: 6,
        logoURI:
          "https://cryptologos.cc/logos/serum-srm-logo.svg?v=014",
      },
      {
        address: "4k3Dyjzvzp8e4wJ7TGLkpvJ7YenqR6AMx7jxUnnGghPf",
        symbol: "RAY",
        name: "Raydium",
        decimals: 6,
        logoURI:
          "https://cryptologos.cc/logos/raydium-ray-logo.svg?v=014",
      },
      {
        address: "orcaE6ZxFtoajT2zF3ahNHPs2bWkm8c5KxjxHPv3RRZ4",
        symbol: "ORCA",
        name: "Orca",
        decimals: 6,
        logoURI:
          "https://cryptologos.cc/logos/orca-orca-logo.svg?v=014",
      },
    ];

    function App() {
      const [walletConnected, setWalletConnected] = useState(false);
      const [provider, setProvider] = useState(null);
      const [publicKey, setPublicKey] = useState(null);
      const [solBalance, setSolBalance] = useState(null);
      const [tokenBalances, setTokenBalances] = useState({});
      const [fromToken, setFromToken] = useState(tokensList[0]); // Default SOL
      const [toToken, setToToken] = useState(tokensList[1]); // Default USDC
      const [amount, setAmount] = useState("");
      const [routes, setRoutes] = useState([]);
      const [selectedRoute, setSelectedRoute] = useState(null);
      const [loadingQuotes, setLoadingQuotes] = useState(false);
      const [swapping, setSwapping] = useState(false);
      const [txStatus, setTxStatus] = useState("");
      const [error, setError] = useState("");
      const [slippage, setSlippage] = useState("50"); // default 0.5%

      // Detect Phantom Provider - supports both desktop & mobile Phantom
      const getPhantomProvider = () => {
        if (window.solana && window.solana.isPhantom) return window.solana;
        if (window.phantom && window.phantom.solana && window.phantom.solana.isPhantom) return window.phantom.solana;
        return null;
      };

      // On mount, check Phantom provider
      useEffect(() => {
        const p = getPhantomProvider();
        setProvider(p);
      }, []);

      // Connect wallet function to request user's approval
      const connectWallet = async () => {
        if (!provider) {
          setError("Phantom wallet not found. Install Phantom or open via Phantom Mobile browser.");
          return;
        }
        try {
          const resp = await provider.connect();
          setPublicKey(new PublicKey(resp.publicKey.toString()));
          setWalletConnected(true);
          setError("");
          setTxStatus("");
        } catch (e) {
          setError("Wallet connection rejected or failed: " + (e.message || e.toString()));
        }
      };

      // Disconnect wallet (optional, often doesn't fully disconnect Phantom)
      const disconnectWallet = async () => {
        try {
          if (provider) await provider.disconnect();
        } catch (e) {
          console.warn("Error disconnecting wallet", e);
        }
        setWalletConnected(false);
        setPublicKey(null);
        setSolBalance(null);
        setTokenBalances({});
        setRoutes([]);
        setSelectedRoute(null);
        setTxStatus("");
        setError("");
        setAmount("");
      };

      // Listen for wallet connect/disconnect events
      useEffect(() => {
        if (!provider) return;
        const onConnect = (pk) => {
          setPublicKey(new PublicKey(pk.toString()));
          setWalletConnected(true);
          setError("");
          setTxStatus("");
        };
        const onDisconnect = () => {
          setWalletConnected(false);
          setPublicKey(null);
          setSolBalance(null);
          setTokenBalances({});
          setRoutes([]);
          setSelectedRoute(null);
          setTxStatus("");
          setError("");
          setAmount("");
        };
        provider.on("connect", onConnect);
        provider.on("disconnect", onDisconnect);
        if (provider.isConnected) onConnect(provider.publicKey);
        return () => {
          provider.removeListener && provider.removeListener("connect", onConnect);
          provider.removeListener && provider.removeListener("disconnect", onDisconnect);
        };
      }, [provider]);

      // Utility to convert amount input to base units for token decimals
      const toBaseUnits = (amountStr, decimals) => {
        try {
          const val = parseFloat(amountStr);
          if (isNaN(val) || val <= 0) return 0;
          return Math.round(val * 10 ** decimals);
        } catch {
          return 0;
        }
      };

      // Fetch SOL and token balances after wallet connect or tokens change
      useEffect(() => {
        if (!walletConnected || !publicKey) {
          setSolBalance(null);
          setTokenBalances({});
          return;
        }
        const fetchBalances = async () => {
          setError("");
          try {
            const solLamports = await connection.getBalance(publicKey);
            setSolBalance(solLamports / 1e9);

            // Token balances
            const balances = {};
            for (let token of tokensList) {
              try {
                const mintPubkey = new PublicKey(token.address);
                const accounts = await connection.getTokenAccountsByOwner(publicKey, { mint: mintPubkey });
                let total = 0;
                for (let acc of accounts.value) {
                  const info = await connection.getParsedAccountInfo(acc.pubkey);
                  if (
                    info.value &&
                    info.value.data &&
                    info.value.data.parsed &&
                    info.value.data.parsed.info &&
                    info.value.data.parsed.info.tokenAmount
                  ) {
                    total += info.value.data.parsed.info.tokenAmount.uiAmount || 0;
                  }
                }
                balances[token.address] = total;
              } catch {
                balances[token.address] = 0;
              }
            }
            setTokenBalances(balances);
          } catch (err) {
            setError("Failed to fetch balances. Confirm wallet connection and network.");
          }
        };
        fetchBalances();
      }, [walletConnected, publicKey]);

      // Fetch swap quotes from Jupiter API
      const getSwapQuotes = async () => {
        setError("");
        setTxStatus("");
        if (!walletConnected || !publicKey) {
          setError("Please connect your wallet.");
          return;
        }
        const amt = parseFloat(amount);
        if (isNaN(amt) || amt <= 0) {
          setError("Enter a valid amount greater than 0.");
          return;
        }
        setLoadingQuotes(true);
        setRoutes([]);
        setSelectedRoute(null);

        try {
          const inputMint = fromToken.symbol === "SOL" ? SOL_MINT : fromToken.address;
          const outputMint = toToken.symbol === "SOL" ? SOL_MINT : toToken.address;
          const amountInBaseUnits = toBaseUnits(amount, fromToken.decimals);
          if (amountInBaseUnits === 0) {
            setError("Amount too small after decimals conversion.");
            setLoadingQuotes(false);
            return;
          }
          const resp = await axios.get(`${JUPITER_API_BASE}/quote`, {
            params: {
              inputMint,
              outputMint,
              amount: amountInBaseUnits,
              slippageBps: parseInt(slippage, 10),
              swapMode: "ExactIn",
            },
            timeout: 15000,
          });
          if (resp.data && Array.isArray(resp.data.data) && resp.data.data.length > 0) {
            setRoutes(resp.data.data);
            setSelectedRoute(resp.data.data[0]);
          } else {
            setError("No swap routes found.");
            setRoutes([]);
            setSelectedRoute(null);
          }
        } catch (err) {
          setError("Failed to fetch swap quotes. Check your network.");
          console.error(err);
        }
        setLoadingQuotes(false);
      };

      // Perform swap transactions using Phantom wallet
      const executeSwap = async () => {
        setError("");
        setTxStatus("");
        if (!walletConnected || !publicKey) {
          setError("Please connect your wallet.");
          return;
        }
        if (!selectedRoute) {
          setError("Select a swap route first.");
          return;
        }
        if (!provider) {
          setError("Phantom wallet not available for signing.");
          return;
        }
        setSwapping(true);

        try {
          const resp = await axios.post(`${JUPITER_API_BASE}/swap`, {
            route: selectedRoute,
            userPublicKey: publicKey.toBase58(),
          }, { timeout: 15000 });

          if (!resp.data || !resp.data.swapTransactions) {
            setError("Failed to get swap transactions.");
            setSwapping(false);
            return;
          }

          const { setupTransaction, swapTransaction } = resp.data.swapTransactions;

          // Perform setup tx if required
          if (setupTransaction) {
            let tx = Transaction.from(Buffer.from(setupTransaction, "base64"));
            tx.feePayer = publicKey;
            const blockhash = (await connection.getLatestBlockhash()).blockhash;
            tx.recentBlockhash = blockhash;
            const signedTx = await provider.signTransaction(tx);
            const txid = await connection.sendRawTransaction(signedTx.serialize());
            setTxStatus("Setup transaction sent: " + txid);
            await connection.confirmTransaction(txid);
          }

          // Perform main swap tx
          let swapTx = Transaction.from(Buffer.from(swapTransaction, "base64"));
          swapTx.feePayer = publicKey;
          const blockhash2 = (await connection.getLatestBlockhash()).blockhash;
          swapTx.recentBlockhash = blockhash2;
          const signedSwapTx = await provider.signTransaction(swapTx);
          const swapTxid = await connection.sendRawTransaction(signedSwapTx.serialize());
          setTxStatus("Swap transaction submitted: " + swapTxid);
          await connection.confirmTransaction(swapTxid);
          setTxStatus("Swap confirmed: " + swapTxid);

          // Refresh balances after swap
          const lamports = await connection.getBalance(publicKey);
          setSolBalance(lamports / 1e9);

          const balances = {};
          for (const token of tokensList) {
            try {
              const mintPubkey = new PublicKey(token.address);
              const accounts = await connection.getTokenAccountsByOwner(publicKey, { mint: mintPubkey });
              let total = 0;
              for (const acc of accounts.value) {
                const info = await connection.getParsedAccountInfo(acc.pubkey);
                if (
                  info.value &&
                  info.value.data &&
                  info.value.data.parsed &&
                  info.value.data.parsed.info &&
                  info.value.data.parsed.info.tokenAmount
                ) total += info.value.data.parsed.info.tokenAmount.uiAmount || 0;
              }
              balances[token.address] = total;
            } catch {
              balances[token.address] = 0;
            }
          }
          setTokenBalances(balances);

          // Reset UI
          setAmount("");
          setRoutes([]);
          setSelectedRoute(null);
          setError("");
        } catch (err) {
          setError("Swap failed: " + (err.message || err.toString()));
          console.error(err);
        }
        setSwapping(false);
      };

      // Swap From/To tokens
      const swapFromTo = () => {
        const oldFrom = fromToken;
        setFromToken(toToken);
        setToToken(oldFrom);
        setAmount("");
        setRoutes([]);
        setSelectedRoute(null);
        setError("");
        setTxStatus("");
      };

      // Display balance helper
      const displayBalance = (token) => {
        if (token.symbol === "SOL") return solBalance === null ? "Loading..." : solBalance.toFixed(4);
        const bal = tokenBalances[token.address];
        return bal === undefined ? "Loading..." : bal.toFixed(4);
      };

      return e("div", null,

        !walletConnected ?
          e("button", { onClick: connectWallet, type: "button", style: { width: "100%", padding: 12, fontSize: 18 }, "aria-label": "Connect Phantom Wallet" }, "Connect Phantom Wallet") :

          e("div", { style: { marginBottom: 18 } },
            e("p", { style: { wordBreak: "break-word", userSelect: "text", fontWeight: "600" } }, "Wallet:", " ", publicKey?.toBase58() ?? ""),
            e("p", { style: { fontWeight: "600" } }, "SOL Balance: ", solBalance === null ? "Loading..." : `${solBalance.toFixed(4)} SOL`),
            e("button", { type: "button", onClick: disconnectWallet, style: { padding: "8px 14px", marginTop: 8 } }, "Disconnect")
          ),

        error && e("p", { className: "error", role: "alert" }, error),

        e("fieldset", { disabled: !walletConnected || loadingQuotes || swapping, style: { borderRadius: 12, padding: 20, marginTop: 12 } },
          e("legend", null, "Swap"),

          e("label", { htmlFor: "fromSelect" }, "From:"),
          e("select", {
            id: "fromSelect",
            style: { marginBottom: 10 },
            value: fromToken.address,
            onChange: e => {
              const val = e.target.value;
              const sel = tokensList.find(t => t.address === val);
              if (sel) {
                setFromToken(sel);
                setRoutes([]);
                setSelectedRoute(null);
                setError("");
                setTxStatus("");
              }
            }
          },
            tokensList.map(t => e("option", { key: t.address, value: t.address }, t.symbol))
          ),
          e("small", null, "Balance: ", displayBalance(fromToken)),

          e("label", { htmlFor: "toSelect" }, "To:"),
          e("select", {
            id: "toSelect",
            style: { marginBottom: 10 },
            value: toToken.address,
            onChange: e => {
              const val = e.target.value;
              const sel = tokensList.find(t => t.address === val);
              if (sel) {
                setToToken(sel);
                setRoutes([]);
                setSelectedRoute(null);
                setError("");
                setTxStatus("");
              }
            }
          },
            tokensList.map(t => e("option", { key: t.address, value: t.address }, t.symbol))
          ),
          e("small", null, "Balance: ", displayBalance(toToken)),

          e("label", { htmlFor: "amountInput" }, "Amount to swap:"),
          e("input", {
            type: "number",
            id: "amountInput",
            placeholder: "0.00",
            value: amount,
            onChange: e => setAmount(e.target.value),
            step: "any",
            min: "0",
            style: { marginBottom: 10 }
          }),

          e("label", { htmlFor: "slippageInput" }, "Slippage tolerance (%):"),
          e("input", {
            type: "number",
            id: "slippageInput",
            min: "0",
            max: "10",
            step: "0.1",
            value: slippage / 100,
            onChange: e => {
              let val = parseFloat(e.target.value);
              if (isNaN(val) || val < 0) val = 0;
              if (val > 10) val = 10;
              setSlippage(Math.round(val * 100));
            },
            style: { marginBottom: 10 }
          }),

          e("button", {
            type: "button",
            className: "btn-swap",
            disabled: !amount || loadingQuotes || swapping || parseFloat(amount) <= 0 || fromToken.address === toToken.address,
            onClick: getSwapQuotes,
          }, loadingQuotes ? "Fetching Swap Routes..." : "Get Swap Quotes")
        ),

        routes.length > 0 && e("fieldset", { style: { marginTop: 20, borderRadius: 12, padding: 20, backgroundColor: "#fff" } },
          e("legend", null, "Available Swap Routes"),
          e("div", { style: { maxHeight: 280, overflowY: "auto" } },
            routes.map(route => {
              const expectedOut = (parseInt(route.outAmount) / 10 ** toToken.decimals).toFixed(6);
              const priceImpactPct = (route.priceImpactPct * 100).toFixed(3);
              const selected = selectedRoute && route.id === selectedRoute.id;
              return e("div", {
                key: route.id,
                className: "route-box" + (selected ? " selected" : ""),
                onClick: () => setSelectedRoute(route),
                onKeyDown: ev => {
                  if (ev.key === 'Enter' || ev.key === ' ') {
                    setSelectedRoute(route);
                  }
                },
                role: 'button',
                tabIndex: 0,
                'aria-pressed': selected,
                style: { userSelect: "none" }
              },
                e("div", e("b", null, `Expected Out: `), `${expectedOut} ${toToken.symbol}`),
                e("div", e("b", null, `Price Impact: `), `${priceImpactPct} %`)
              );
            })
          ),
          e("button", {
            type: "button",
            disabled: !selectedRoute || swapping,
            onClick: executeSwap,
            style: { marginTop: 18, padding: 14, width: "100%", fontWeight: "700", fontSize: "1.1rem" }
          }, swapping ? "Swapping..." : `Swap ${amount} ${fromToken.symbol} → ${toToken.symbol}`)
        ),

        txStatus && e("p", { className: "status", role: "alert" }, txStatus),

        e("footer", null, "Powered by ",
          e("a", { href: "https://solana.com", target: "_blank", rel: "noopener noreferrer" }, "Solana"),
          ", ",
          e("a", { href: "https://phantom.app", target: "_blank", rel: "noopener noreferrer" }, "Phantom"),
          " & ",
          e("a", { href: "https://jup.ag", target: "_blank", rel: "noopener noreferrer" }, "Jupiter")
        ),
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(e(App));
  </script>
</body>

</html>
